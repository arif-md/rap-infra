name: Infra - Provision and Deploy (azd)

on:
  workflow_dispatch:
    inputs:
      targetEnv:
        description: "GitHub Environment name to run under (e.g., test/train/prod)"
        required: false
        default: "dev"
  push:
    branches: [ main ]
    paths:
      - 'azure.yaml'
      - 'main.bicep'
      - 'main.parameters.json'
      - 'app/**'
      - 'modules/**'
      - 'shared/**'
      - 'scripts/**'
  repository_dispatch:
    types: [ frontend-image-pushed ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.client_payload.targetEnv || inputs.targetEnv || vars.DEFAULT_GITHUB_ENV || 'dev' }}
    env:
      # Use environment-scoped variables; define these per GitHub Environment (test/train/prod)
      AZURE_ENV_NAME: ${{ vars.AZURE_ENV_NAME || 'dev' }}
      AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
      AZURE_ACR_NAME: ${{ vars.AZURE_ACR_NAME }}
      AZURE_ACR_RESOURCE_GROUP: ${{ vars.AZURE_ACR_RESOURCE_GROUP }}
    outputs:
      frontendFqdn: ${{ steps.expose_endpoints.outputs.frontendFqdn }}
    permissions:
      id-token: write   # for OIDC
      contents: write   # required for repository_dispatch using GITHUB_TOKEN
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Azure Developer CLI (preferred)
        uses: Azure/setup-azd@v2
        with:
          version: latest
        continue-on-error: true

      - name: Ensure azd installed (fallback)
        run: |
          if ! command -v azd >/dev/null 2>&1; then
            echo "setup-azd failed; installing via script"
            curl -fsSL https://aka.ms/install-azd.sh | bash
            echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          fi
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          echo "Authenticating azd using GitHub OIDC provider"
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          # Verify Azure CLI is authenticated for this job
          az account show -o none
          az account get-access-token -o none
          # Verify azd is installed and on PATH
          command -v azd >/dev/null 2>&1
          azd version

      - name: "Sanity: az context"
        shell: bash
        run: |
          set -euo pipefail
          CTX=$(az account show --query "{tenant:tenantId, sub:id, user:user.name}" -o tsv)
          echo "AZ context: $CTX"

      - name: "Sanity: environment variables (resolved)"
        shell: bash
        run: |
          echo "Using GitHub Environment: ${{ job.environment.name }}"
          echo "AZURE_ENV_NAME=$AZURE_ENV_NAME"
          echo "AZURE_RESOURCE_GROUP=$AZURE_RESOURCE_GROUP"
          echo "AZURE_ACR_NAME=$AZURE_ACR_NAME"
          echo "AZURE_ACR_RESOURCE_GROUP=$AZURE_ACR_RESOURCE_GROUP"

      - name: Enable azd alpha features (deployment stacks)
        run: azd config set alpha.deployment.stacks on

      - name: Ensure AZURE_ENV_NAME default
        run: |
          if [ -z "$AZURE_ENV_NAME" ]; then
            # If not provided via repo/environment vars, derive from the ref that triggered the run.
            # GITHUB_REF_NAME is the short branch/tag (e.g., "main" or "v1.2.3"). Default to "dev" if unavailable.
            NAME="${GITHUB_REF_NAME:-dev}"
            # Normalize to a safe environment name:
            #  - tr: make lowercase
            #  - sed 's/[^a-z0-9-]/-/g': replace any character that's not a-z, 0-9, or '-' with '-'
            #    This helps comply with Azure naming constraints for resources derived from env name.
            SAFE=$(echo "$NAME" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
            # Write the resolved value to GITHUB_ENV to make it available to subsequent steps in this job.
            echo "AZURE_ENV_NAME=$SAFE" >> $GITHUB_ENV
            echo "Using fallback AZURE_ENV_NAME: $SAFE"
          else
            echo "Using provided AZURE_ENV_NAME: $AZURE_ENV_NAME"
          fi

      - name: Prepare azd environment
        run: |
          azd env new $AZURE_ENV_NAME --no-prompt || true
          azd env set AZURE_ENV_NAME "$AZURE_ENV_NAME"
          azd env set AZURE_RESOURCE_GROUP "$AZURE_RESOURCE_GROUP"
          if [ -n "$AZURE_ACR_RESOURCE_GROUP" ]; then
            azd env set AZURE_ACR_RESOURCE_GROUP "$AZURE_ACR_RESOURCE_GROUP"
          fi
          # Derive location from the resource group if needed for diagnostics (no longer stored in env)
          RG_LOC=$(az group show -n "$AZURE_RESOURCE_GROUP" --query location -o tsv 2>/dev/null || true)
          if [ -n "$RG_LOC" ]; then
            echo "Resolved location from RG '$AZURE_RESOURCE_GROUP': $RG_LOC"
          else
            echo "Warning: Could not resolve location for RG '$AZURE_RESOURCE_GROUP'"
          fi
          azd env set AZURE_ACR_NAME "$AZURE_ACR_NAME"
          azd env set AZURE_SUBSCRIPTION_ID "${{ secrets.AZURE_SUBSCRIPTION_ID }}"

      - name: Resolve image from ACR (fallback to public)
        # Only do this for direct runs (push/manual). For repository_dispatch we always use the provided image.
        if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
        shell: bash
        run: |
          set -euo pipefail
          REGISTRY="${AZURE_ACR_NAME}.azurecr.io"
          REPO="raptor/frontend-${AZURE_ENV_NAME}"
          echo "Looking for latest digest in ACR: $REGISTRY/$REPO"
          DIGEST=$(az acr repository show-manifests -n "$AZURE_ACR_NAME" --repository "$REPO" --orderby time_desc --top 1 --query "[0].digest" -o tsv 2>/dev/null || true)
          if [ -n "$DIGEST" ]; then
            IMAGE="$REGISTRY/$REPO@$DIGEST"
            echo "Found image in ACR: $IMAGE"
            azd env set SERVICE_FRONTEND_IMAGE_NAME "$IMAGE"
            azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false
          else
            FALLBACK="mcr.microsoft.com/azuredocs/containerapps-helloworld:latest"
            echo "No image found in ACR for repo '$REPO'. Using fallback: $FALLBACK"
            azd env set SERVICE_FRONTEND_IMAGE_NAME "$FALLBACK"
            azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT true
          fi

      - name: Ensure ACR exists (preprovision)
        shell: bash
        run: |
          chmod +x ./scripts/ensure-acr.sh
          ./scripts/ensure-acr.sh

      - name: Accept image from repository_dispatch (optional)
        if: github.event_name == 'repository_dispatch' && github.event.action == 'frontend-image-pushed'
        run: |
          IMG='${{ github.event.client_payload.image }}'
          if [ -n "$IMG" ]; then
            echo "Using pre-built image: $IMG"
            azd env set SERVICE_FRONTEND_IMAGE_NAME "$IMG"
            DOMAIN="${IMG%%/*}"
            if [ "$DOMAIN" = "${AZURE_ACR_NAME}.azurecr.io" ]; then
              azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false
            else
              azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT true
            fi
          fi

      - name: Validate image vs ACR binding (guard)
        shell: bash
        run: |
          set -euo pipefail
          IMG=$(azd env get-value SERVICE_FRONTEND_IMAGE_NAME || true)
          SKIP=$(azd env get-value SKIP_ACR_PULL_ROLE_ASSIGNMENT || echo true)
          if [ -z "$IMG" ]; then
            echo "SERVICE_FRONTEND_IMAGE_NAME is not set; nothing to validate."
            exit 0
          fi
          DOMAIN="${IMG%%/*}"
          ACR_DOMAIN="${AZURE_ACR_NAME}.azurecr.io"
          if [ "$DOMAIN" = "$ACR_DOMAIN" ] && [ "$SKIP" = "true" ]; then
            echo "Inconsistent configuration: Image is from ACR ($ACR_DOMAIN) but SKIP_ACR_PULL_ROLE_ASSIGNMENT=true. Set SKIP=false or use a public image." >&2
            exit 1
          fi
          if [ "$DOMAIN" != "$ACR_DOMAIN" ] && [ "$SKIP" = "false" ]; then
            echo "Inconsistent configuration: Image is NOT from ACR ($DOMAIN) but SKIP_ACR_PULL_ROLE_ASSIGNMENT=false. Set SKIP=true or use an ACR image." >&2
            exit 1
          fi
          echo "Image/ACR binding validation passed."

      - name: Fast image-only update (skip provision when possible)
        if: (github.event_name == 'repository_dispatch' && github.event.action == 'frontend-image-pushed') || github.event_name == 'workflow_dispatch'
        id: fastpath
        shell: bash
        run: |
          set -euo pipefail
          APP_NAME=$(echo "${AZURE_ENV_NAME}-rap-fe" | tr '[:upper:]' '[:lower:]')
          IMG=$(azd env get-value SERVICE_FRONTEND_IMAGE_NAME || true)
          if [ -z "$IMG" ]; then
            echo "No configured image; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          DIGEST_PART="${IMG#*@}"
          if [ "$IMG" = "$DIGEST_PART" ]; then
            echo "Image is not digest-form; skipping fast-path: $IMG"
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          if ! az containerapp show -n "$APP_NAME" -g "$AZURE_RESOURCE_GROUP" >/dev/null 2>&1; then
            echo "Container App does not exist; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          # Determine registry of the new image
          DOMAIN="${IMG%%/*}"
          ACR_DOMAIN="${AZURE_ACR_NAME}.azurecr.io"
          echo "[fast-path] App=$APP_NAME"
          echo "[fast-path] Image=$IMG"
          echo "[fast-path] New image domain: $DOMAIN"
          echo "[fast-path] ACR name/domain: ${AZURE_ACR_NAME}/$ACR_DOMAIN"
          if [ "$DOMAIN" = "$ACR_DOMAIN" ]; then
            echo "Container App exists. Preparing ACR registry access for: $DOMAIN"
          az extension add -n containerapp -y >/dev/null 2>&1 || true
          APP_JSON=$(az containerapp show -n "$APP_NAME" -g "$AZURE_RESOURCE_GROUP" -o json)
          ID_TYPE=$(printf '%s' "$APP_JSON" | jq -r '.identity.type // "None"')
            echo "[fast-path] Identity type (pre): $ID_TYPE"
          if [ "$ID_TYPE" = "None" ] || [ -z "$ID_TYPE" ]; then
            echo "Assigning system-managed identity to Container App (was: $ID_TYPE)"
            az containerapp identity assign -n "$APP_NAME" -g "$AZURE_RESOURCE_GROUP" --system-assigned >/dev/null
            # Refresh identity info
            APP_JSON=$(az containerapp show -n "$APP_NAME" -g "$AZURE_RESOURCE_GROUP" -o json)
            ID_TYPE=$(printf '%s' "$APP_JSON" | jq -r '.identity.type // "None"')
              echo "[fast-path] Identity type (post-assign): $ID_TYPE"
          fi
          ACR_RG="${AZURE_ACR_RESOURCE_GROUP:-$AZURE_RESOURCE_GROUP}"
          ACR_ID=$(az acr show -n "$AZURE_ACR_NAME" -g "$ACR_RG" --query id -o tsv 2>/dev/null || true)
            echo "[fast-path] ACR RG: $ACR_RG"
            echo "[fast-path] ACR ID: ${ACR_ID:-'(unresolved)'}"
          if [ -z "$ACR_ID" ]; then
            echo "Could not resolve ACR resource id for $AZURE_ACR_NAME in RG $ACR_RG; falling back."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          ROLE_ID="$(az role definition list --name AcrPull --query "[0].name" -o tsv)"
          if [ "$ID_TYPE" = "SystemAssigned" ] || [ "$ID_TYPE" = "SystemAssigned,UserAssigned" ]; then
            PRINCIPAL_ID=$(printf '%s' "$APP_JSON" | jq -r '.identity.principalId // empty')
              echo "[fast-path] System principal: ${PRINCIPAL_ID:-'(none)'}"
            if [ -n "$PRINCIPAL_ID" ]; then
              echo "Ensuring AcrPull for system-assigned identity $PRINCIPAL_ID"
              az role assignment create --assignee-object-id "$PRINCIPAL_ID" --assignee-principal-type ServicePrincipal --role "$ROLE_ID" --scope "$ACR_ID" >/dev/null 2>&1 || true
              echo "Binding registry to app using system identity"
              az containerapp registry set -n "$APP_NAME" -g "$AZURE_RESOURCE_GROUP" --server "$ACR_DOMAIN" --identity system >/dev/null
            fi
          fi
          # If user-assigned identities exist, bind the first one too
          UAI_KEYS=$(printf '%s' "$APP_JSON" | jq -r '.identity.userAssignedIdentities | keys[]?')
          if [ -n "$UAI_KEYS" ]; then
            FIRST_UAI=$(printf '%s' "$UAI_KEYS" | head -n 1)
              echo "[fast-path] First UAI: ${FIRST_UAI:-'(none)'}"
            if [ -n "$FIRST_UAI" ]; then
              UAI_PRINCIPAL=$(az identity show --ids "$FIRST_UAI" --query principalId -o tsv 2>/dev/null || true)
                echo "[fast-path] UAI principal: ${UAI_PRINCIPAL:-'(none)'}"
              if [ -n "$UAI_PRINCIPAL" ]; then
                echo "Ensuring AcrPull for user-assigned identity $UAI_PRINCIPAL"
                az role assignment create --assignee-object-id "$UAI_PRINCIPAL" --assignee-principal-type ServicePrincipal --role "$ROLE_ID" --scope "$ACR_ID" >/dev/null 2>&1 || true
                echo "Binding registry to app using user-assigned identity"
                az containerapp registry set -n "$APP_NAME" -g "$AZURE_RESOURCE_GROUP" --server "$ACR_DOMAIN" --identity "$FIRST_UAI" >/dev/null
              fi
            fi
          fi
          else
            echo "Image domain is not ACR; no registry binding required for fast path."
          fi
          echo "Performing direct image update to: $IMG"
          az containerapp update -n "$APP_NAME" -g "$AZURE_RESOURCE_GROUP" --image "$IMG"
          echo "didFastPath=true" >> $GITHUB_OUTPUT

      - name: azd up (provision + deploy)
        if: steps.fastpath.outputs.didFastPath != 'true'
        run: azd up --no-prompt --environment "$AZURE_ENV_NAME"

      - name: Show effective deployed image
        id: effective_image
        shell: bash
        run: |
          set -euo pipefail
          CONFIGURED_IMG=$(azd env get-value SERVICE_FRONTEND_IMAGE_NAME || true)
          APP_NAME=$(echo "${AZURE_ENV_NAME}-rap-fe" | tr '[:upper:]' '[:lower:]')
          az extension add -n containerapp -y >/dev/null 2>&1 || true
          DEPLOYED_IMG=$(az containerapp show -n "$APP_NAME" -g "$AZURE_RESOURCE_GROUP" --query "properties.template.containers[0].image" -o tsv 2>/dev/null || true)
          echo "configuredImage=$CONFIGURED_IMG" >> $GITHUB_OUTPUT
          echo "deployedImage=$DEPLOYED_IMG" >> $GITHUB_OUTPUT
          echo "Configured image: ${CONFIGURED_IMG:-'(not set)'}"
          echo "Deployed image:   ${DEPLOYED_IMG:-'(unavailable)'}"
          {
            echo "### Deployed image"
            echo
            echo "- Configured: ${CONFIGURED_IMG:-'(not set)'}"
            echo "- Deployed: ${DEPLOYED_IMG:-'(unavailable)'}"
          } >> $GITHUB_STEP_SUMMARY

      - name: Persist deployment metadata to tags (base env)
        if: success()
        shell: bash
        run: |
          set -euo pipefail
          APP_NAME=$(echo "${AZURE_ENV_NAME}-rap-fe" | tr '[:upper:]' '[:lower:]')
          RG="$AZURE_RESOURCE_GROUP"
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if [ -z "$SUB" ]; then SUB=$(az account show --query id -o tsv 2>/dev/null || true); fi
          # Prefer configured image (what we attempted to deploy); fall back to the actual deployed image read back
          IMG='${{ steps.effective_image.outputs.configuredImage }}'
          if [ -z "$IMG" ]; then IMG='${{ steps.effective_image.outputs.deployedImage }}'; fi
          if [ -z "$IMG" ]; then
            echo "No image detected; skipping tag persistence."
            exit 0
          fi
          DIGEST="${IMG#*@}"
          if [ "$IMG" = "$DIGEST" ]; then
            echo "Image is not in digest form; skipping tag persistence: $IMG"
            exit 0
          fi
          DOMAIN="${IMG%%/*}"
          REPO_PATH="${IMG#*/}"
          REPO_NAME="${REPO_PATH%@*}"
          echo "Resolved image: domain=$DOMAIN repo=$REPO_NAME digest=$DIGEST"
          # Attempt to resolve commit from OCI labels when image is in ACR
          NEW_SHA=""
          if echo "$DOMAIN" | grep -q ".azurecr.io$"; then
            REG_NAME=$(echo "$DOMAIN" | sed 's/\\.azurecr\\.io$//')
            get_commit_from_labels() {
              local reg="$1" repo="$2" dig="$3"
              if [ -z "$dig" ]; then echo ""; return 0; fi
              local tok
              tok=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
              [ -z "$tok" ] && { echo ""; return 0; }
              local base="https://${reg}.azurecr.io/v2/${repo}"
              local mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json' "$base/manifests/$dig" 2>/dev/null || true)
              [ -z "$mf" ] && { echo ""; return 0; }
              local media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')
              if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
                local child=$(printf '%s' "$mf" | jq -r '.manifests[0].digest // empty')
                [ -n "$child" ] && mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$base/manifests/$child" 2>/dev/null || true)
              fi
              local cfg=$(printf '%s' "$mf" | jq -r '.config.digest // empty')
              [ -z "$cfg" ] && { echo ""; return 0; }
              local cfgJson=$(curl -fsSL -H "Authorization: Bearer $tok" "$base/blobs/$cfg" 2>/dev/null || true)
              [ -z "$cfgJson" ] && { echo ""; return 0; }
              local rev=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
              printf '%s' "$rev"
            }
            NEW_SHA=$(get_commit_from_labels "$REG_NAME" "$REPO_NAME" "$DIGEST")
          fi
          echo "Updating tags on Container App '$APP_NAME' in RG '$RG'"
          az resource update -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} \
            --resource-type "Microsoft.App/containerApps" \
            --set "tags['raptor.lastDigest']"="$DIGEST" "tags['raptor.lastCommit']"="$NEW_SHA" >/dev/null || true

      - name: Prepare promotion target
        if: success() && github.event_name == 'repository_dispatch' && github.event.action == 'frontend-image-pushed'
        id: promo
        shell: bash
        run: |
          set -euo pipefail
          TARGET="${{ vars.PROMOTE_REPO || github.repository }}"
          echo "repo=$TARGET" >> $GITHUB_OUTPUT
          IMG='${{ steps.effective_image.outputs.configuredImage }}'
          echo "image=$IMG" >> $GITHUB_OUTPUT
          # Resolve the source repository for commit history / compare links
          # Prefer value provided by the originating event payload, then a configured var, else fall back to current repo
          SRC_REPO='${{ github.event.client_payload.sourceRepo || vars.FRONTEND_SOURCE_REPO || '' }}'
          if [ -z "$SRC_REPO" ]; then
            SRC_REPO="$GITHUB_REPOSITORY"
            echo "Warning: sourceRepo not provided in payload or vars; falling back to $SRC_REPO"
          fi
          echo "sourceRepo=$SRC_REPO" >> $GITHUB_OUTPUT
          # Determine the promotion environment: prefer payload.promoEnv, fallback to configured default, else 'test'
          PROMO_ENV='${{ github.event.client_payload.promoEnv || vars.PROMO_ENV_NAME || 'test' }}'
          echo "env=$PROMO_ENV" >> $GITHUB_OUTPUT
          echo "Promotion will target repo: $TARGET" 
          echo "Image to promote: $IMG"
          echo "Source repo: $SRC_REPO"
          echo "Promotion environment: $PROMO_ENV"

      - name: Log and wait before promotion dispatch
        if: success() && steps.promo.outputs.image && steps.promo.outputs.repo
        shell: bash
        run: |
          echo "Dev deployment successful. Dispatching promotion event in 3 seconds..."
          sleep 3

      - name: Dispatch promotion (same-repo)
        if: success() && steps.promo.outputs.repo == github.repository
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ github.token }}
          repository: ${{ steps.promo.outputs.repo }}
          event-type: frontend-image-promote
          client-payload: |
            {"image": "${{ steps.promo.outputs.image }}",
             "resourceGroup": "${{ vars.PROMO_AZURE_RESOURCE_GROUP || format('rg-raptor-{0}', steps.promo.outputs.env) }}",
             "acrName": "${{ vars.PROMO_AZURE_ACR_NAME }}",
             "sourceRepo": "${{ steps.promo.outputs.sourceRepo }}",
             "targetEnv": "${{ steps.promo.outputs.env }}",
             "targetResourceGroup": "${{ vars.PROMO_AZURE_RESOURCE_GROUP || format('rg-raptor-{0}', steps.promo.outputs.env) }}",
             "targetAcrName": "${{ vars.PROMO_AZURE_ACR_NAME }}",
             "targetSubscriptionId": "${{ vars.PROMO_AZURE_SUBSCRIPTION_ID || secrets.AZURE_SUBSCRIPTION_ID }}"}

      - name: Verify dispatch token for cross-repo
        if: success() && steps.promo.outputs.repo && steps.promo.outputs.repo != '' && steps.promo.outputs.repo != github.repository
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.GH_PAT_REPO_DISPATCH }}" ]; then
            echo "Missing secret GH_PAT_REPO_DISPATCH for cross-repo dispatch to ${{ steps.promo.outputs.repo }}." >&2
            echo "Provide a PAT with repo (classic) OR a fine-grained PAT with Actions: Read+write and Contents: Read+write on the target repo." >&2
            exit 1
          fi

      - name: Dispatch promotion (cross-repo)
        if: success() && steps.promo.outputs.repo && steps.promo.outputs.repo != github.repository
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.GH_PAT_REPO_DISPATCH }}
          repository: ${{ steps.promo.outputs.repo }}
          event-type: frontend-image-promote
          client-payload: |
            {"image": "${{ steps.promo.outputs.image }}",
             "resourceGroup": "${{ vars.PROMO_AZURE_RESOURCE_GROUP || format('rg-raptor-{0}', steps.promo.outputs.env) }}",
             "acrName": "${{ vars.PROMO_AZURE_ACR_NAME }}",
             "sourceRepo": "${{ steps.promo.outputs.sourceRepo }}",
             "targetEnv": "${{ steps.promo.outputs.env }}",
             "targetResourceGroup": "${{ vars.PROMO_AZURE_RESOURCE_GROUP || format('rg-raptor-{0}', steps.promo.outputs.env) }}",
             "targetAcrName": "${{ vars.PROMO_AZURE_ACR_NAME }}",
             "targetSubscriptionId": "${{ vars.PROMO_AZURE_SUBSCRIPTION_ID || secrets.AZURE_SUBSCRIPTION_ID }}"}

      - name: Expose deployment endpoints
        id: expose_endpoints
        run: |
          set -euo pipefail
          RAW=$(azd env get-value frontendFqdn 2>/dev/null || true)
          # Use only the first line and strip CR to avoid breaking GitHub output/env files
          FQDN=$(printf '%s' "$RAW" | tr -d '\r' | head -n1)
          # Treat any 'ERROR:' response from azd as empty
          if printf '%s' "$FQDN" | grep -qi '^error:'; then FQDN=""; fi
          # Fallback: read from Container App if not present in azd env
          if [ -z "$FQDN" ]; then
            APP_NAME=$(echo "${AZURE_ENV_NAME}-rap-fe" | tr '[:upper:]' '[:lower:]')
            az extension add -n containerapp -y >/dev/null 2>&1 || true
            CA_FQDN=$(az containerapp show -n "$APP_NAME" -g "$AZURE_RESOURCE_GROUP" --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || true)
            # Some environments return 'null' literal; normalize to empty
            if [ "$CA_FQDN" = "null" ]; then CA_FQDN=""; fi
            FQDN=$(printf '%s' "$CA_FQDN" | tr -d '\r' | head -n1)
            if [ -n "$FQDN" ]; then
              azd env set frontendFqdn "$FQDN" >/dev/null || true
            fi
          fi
          # Only write outputs/env when FQDN is a non-empty, single-line value
          if [ -n "$FQDN" ]; then
            echo "frontendFqdn=$FQDN" >> $GITHUB_OUTPUT
            echo "DEPLOY_URL=$FQDN" >> $GITHUB_ENV
            echo "Frontend URL: https://$FQDN"
          else
            echo "Frontend URL not available"
          fi
          {
            echo "### Deployment endpoints"
            echo ""
            if [ -n "$FQDN" ]; then
              echo "- Frontend: https://$FQDN"
            else
              echo "- Frontend: (not available)"
            fi
          } >> $GITHUB_STEP_SUMMARY
