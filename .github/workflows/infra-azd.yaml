name: Infra - Provision and Deploy (azd)

on:
  workflow_dispatch:
    inputs:
      targetEnv:
        description: "GitHub Environment name to run under (e.g., test/train/prod)"
        required: false
        default: "test"
  push:
    branches: [ main ]
    paths:
      - 'azure.yaml'
      - 'main.bicep'
      - 'main.parameters.json'
      - 'app/**'
      - 'modules/**'
      - 'shared/**'
      - 'scripts/**'
  repository_dispatch:
    types: [ frontend-image-pushed ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.client_payload.targetEnv || inputs.targetEnv || vars.DEFAULT_GITHUB_ENV || 'test' }}
    env:
      # Use environment-scoped variables; define these per GitHub Environment (test/train/prod)
      AZURE_ENV_NAME: ${{ vars.AZURE_ENV_NAME || 'dev' }}
      AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
      AZURE_ACR_NAME: ${{ vars.AZURE_ACR_NAME }}
      AZURE_ACR_RESOURCE_GROUP: ${{ vars.AZURE_ACR_RESOURCE_GROUP }}
    outputs:
      frontendFqdn: ${{ steps.expose_endpoints.outputs.frontendFqdn }}
    permissions:
      id-token: write   # for OIDC
      contents: write   # required for repository_dispatch using GITHUB_TOKEN
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Azure Developer CLI (preferred)
        uses: Azure/setup-azd@v2
        with:
          version: latest
        continue-on-error: true

      - name: Ensure azd installed (fallback)
        run: |
          if ! command -v azd >/dev/null 2>&1; then
            echo "setup-azd failed; installing via script"
            curl -fsSL https://aka.ms/install-azd.sh | bash
            echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          fi
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          echo "Authenticating azd using GitHub OIDC provider"
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          # Verify Azure CLI is authenticated for this job
          az account show -o none
          az account get-access-token -o none
          # Verify azd is installed and on PATH
          command -v azd >/dev/null 2>&1
          azd version

      - name: "Sanity: az context"
        shell: bash
        run: |
          set -euo pipefail
          CTX=$(az account show --query "{tenant:tenantId, sub:id, user:user.name}" -o tsv)
          echo "AZ context: $CTX"

      - name: "Sanity: environment variables (resolved)"
        shell: bash
        run: |
          echo "Using GitHub Environment: ${{ job.environment.name }}"
          echo "AZURE_ENV_NAME=$AZURE_ENV_NAME"
          echo "AZURE_RESOURCE_GROUP=$AZURE_RESOURCE_GROUP"
          echo "AZURE_ACR_NAME=$AZURE_ACR_NAME"
          echo "AZURE_ACR_RESOURCE_GROUP=$AZURE_ACR_RESOURCE_GROUP"

      - name: Enable azd alpha features (deployment stacks)
        run: azd config set alpha.deployment.stacks on

      - name: Ensure AZURE_ENV_NAME default
        run: |
          if [ -z "$AZURE_ENV_NAME" ]; then
            # If not provided via repo/environment vars, derive from the ref that triggered the run.
            # GITHUB_REF_NAME is the short branch/tag (e.g., "main" or "v1.2.3"). Default to "dev" if unavailable.
            NAME="${GITHUB_REF_NAME:-dev}"
            # Normalize to a safe environment name:
            #  - tr: make lowercase
            #  - sed 's/[^a-z0-9-]/-/g': replace any character that's not a-z, 0-9, or '-' with '-'
            #    This helps comply with Azure naming constraints for resources derived from env name.
            SAFE=$(echo "$NAME" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
            # Write the resolved value to GITHUB_ENV to make it available to subsequent steps in this job.
            echo "AZURE_ENV_NAME=$SAFE" >> $GITHUB_ENV
            echo "Using fallback AZURE_ENV_NAME: $SAFE"
          else
            echo "Using provided AZURE_ENV_NAME: $AZURE_ENV_NAME"
          fi

      - name: Prepare azd environment
        run: |
          azd env new $AZURE_ENV_NAME --no-prompt || true
          azd env set AZURE_ENV_NAME "$AZURE_ENV_NAME"
          azd env set AZURE_RESOURCE_GROUP "$AZURE_RESOURCE_GROUP"
          if [ -n "$AZURE_ACR_RESOURCE_GROUP" ]; then
            azd env set AZURE_ACR_RESOURCE_GROUP "$AZURE_ACR_RESOURCE_GROUP"
          fi
          # Derive location from the resource group if needed for diagnostics (no longer stored in env)
          RG_LOC=$(az group show -n "$AZURE_RESOURCE_GROUP" --query location -o tsv 2>/dev/null || true)
          if [ -n "$RG_LOC" ]; then
            echo "Resolved location from RG '$AZURE_RESOURCE_GROUP': $RG_LOC"
          else
            echo "Warning: Could not resolve location for RG '$AZURE_RESOURCE_GROUP'"
          fi
          azd env set AZURE_ACR_NAME "$AZURE_ACR_NAME"
          azd env set AZURE_SUBSCRIPTION_ID "${{ secrets.AZURE_SUBSCRIPTION_ID }}"

      - name: Resolve image from ACR (fallback to public)
        # Only do this for direct runs (push/manual). For repository_dispatch we always use the provided image.
        if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
        shell: bash
        run: |
          set -euo pipefail
          REGISTRY="${AZURE_ACR_NAME}.azurecr.io"
          REPO="raptor/frontend-${AZURE_ENV_NAME}"
          echo "Looking for latest digest in ACR: $REGISTRY/$REPO"
          DIGEST=$(az acr repository show-manifests -n "$AZURE_ACR_NAME" --repository "$REPO" --orderby time_desc --top 1 --query "[0].digest" -o tsv 2>/dev/null || true)
          if [ -n "$DIGEST" ]; then
            IMAGE="$REGISTRY/$REPO@$DIGEST"
            echo "Found image in ACR: $IMAGE"
            azd env set SERVICE_FRONTEND_IMAGE_NAME "$IMAGE"
            azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false
          else
            FALLBACK="mcr.microsoft.com/azuredocs/containerapps-helloworld:latest"
            echo "No image found in ACR for repo '$REPO'. Using fallback: $FALLBACK"
            azd env set SERVICE_FRONTEND_IMAGE_NAME "$FALLBACK"
            azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT true
          fi

      - name: Ensure ACR exists (preprovision)
        shell: bash
        run: |
          chmod +x ./scripts/ensure-acr.sh
          ./scripts/ensure-acr.sh

      - name: Accept image from repository_dispatch (optional)
        if: github.event_name == 'repository_dispatch' && github.event.action == 'frontend-image-pushed'
        run: |
          IMG='${{ github.event.client_payload.image }}'
          if [ -n "$IMG" ]; then
            echo "Using pre-built image: $IMG"
            azd env set SERVICE_FRONTEND_IMAGE_NAME "$IMG"
            DOMAIN="${IMG%%/*}"
            if [ "$DOMAIN" = "${AZURE_ACR_NAME}.azurecr.io" ]; then
              azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false
            else
              azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT true
            fi
          fi

      - name: Validate image vs ACR binding (guard)
        shell: bash
        run: |
          set -euo pipefail
          IMG=$(azd env get-value SERVICE_FRONTEND_IMAGE_NAME || true)
          SKIP=$(azd env get-value SKIP_ACR_PULL_ROLE_ASSIGNMENT || echo true)
          if [ -z "$IMG" ]; then
            echo "SERVICE_FRONTEND_IMAGE_NAME is not set; nothing to validate."
            exit 0
          fi
          DOMAIN="${IMG%%/*}"
          ACR_DOMAIN="${AZURE_ACR_NAME}.azurecr.io"
          if [ "$DOMAIN" = "$ACR_DOMAIN" ] && [ "$SKIP" = "true" ]; then
            echo "Inconsistent configuration: Image is from ACR ($ACR_DOMAIN) but SKIP_ACR_PULL_ROLE_ASSIGNMENT=true. Set SKIP=false or use a public image." >&2
            exit 1
          fi
          if [ "$DOMAIN" != "$ACR_DOMAIN" ] && [ "$SKIP" = "false" ]; then
            echo "Inconsistent configuration: Image is NOT from ACR ($DOMAIN) but SKIP_ACR_PULL_ROLE_ASSIGNMENT=false. Set SKIP=true or use an ACR image." >&2
            exit 1
          fi
          echo "Image/ACR binding validation passed."

      - name: azd up (provision + deploy)
        run: azd up --no-prompt --environment "$AZURE_ENV_NAME"

      - name: Show effective deployed image
        id: effective_image
        shell: bash
        run: |
          set -euo pipefail
          CONFIGURED_IMG=$(azd env get-value SERVICE_FRONTEND_IMAGE_NAME || true)
          APP_NAME=$(echo "${AZURE_ENV_NAME}-rap-fe" | tr '[:upper:]' '[:lower:]')
          az extension add -n containerapp -y >/dev/null 2>&1 || true
          DEPLOYED_IMG=$(az containerapp show -n "$APP_NAME" -g "$AZURE_RESOURCE_GROUP" --query "properties.template.containers[0].image" -o tsv 2>/dev/null || true)
          echo "configuredImage=$CONFIGURED_IMG" >> $GITHUB_OUTPUT
          echo "deployedImage=$DEPLOYED_IMG" >> $GITHUB_OUTPUT
          echo "Configured image: ${CONFIGURED_IMG:-'(not set)'}"
          echo "Deployed image:   ${DEPLOYED_IMG:-'(unavailable)'}"
          {
            echo "### Deployed image"
            echo
            echo "- Configured: ${CONFIGURED_IMG:-'(not set)'}"
            echo "- Deployed: ${DEPLOYED_IMG:-'(unavailable)'}"
          } >> $GITHUB_STEP_SUMMARY

      - name: Prepare promotion target
        if: success() && github.event_name == 'repository_dispatch' && github.event.action == 'frontend-image-pushed'
        id: promo
        shell: bash
        run: |
          set -euo pipefail
          TARGET="${{ vars.PROMOTE_REPO || github.repository }}"
          echo "repo=$TARGET" >> $GITHUB_OUTPUT
          IMG='${{ steps.effective_image.outputs.configuredImage }}'
          echo "image=$IMG" >> $GITHUB_OUTPUT
          # Resolve the source repository for commit history / compare links
          # Prefer value provided by the originating event payload, then a configured var, else fall back to current repo
          SRC_REPO='${{ github.event.client_payload.sourceRepo || vars.FRONTEND_SOURCE_REPO || '' }}'
          if [ -z "$SRC_REPO" ]; then
            SRC_REPO="$GITHUB_REPOSITORY"
            echo "Warning: sourceRepo not provided in payload or vars; falling back to $SRC_REPO"
          fi
          echo "sourceRepo=$SRC_REPO" >> $GITHUB_OUTPUT
          echo "Promotion will target repo: $TARGET" 
          echo "Image to promote: $IMG"
          echo "Source repo: $SRC_REPO"

      - name: Log and wait before promotion dispatch
        if: success() && steps.promo.outputs.image && steps.promo.outputs.repo
        shell: bash
        run: |
          echo "Dev deployment successful. Dispatching promotion event in 3 seconds..."
          sleep 3

      - name: Dispatch promotion (same-repo)
        if: success() && steps.promo.outputs.repo == github.repository
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ github.token }}
          repository: ${{ steps.promo.outputs.repo }}
          event-type: frontend-image-promote
          client-payload: |
            {"image": "${{ steps.promo.outputs.image }}",
             "resourceGroup": "${{ vars.PROMO_AZURE_RESOURCE_GROUP || format('rg-raptor-{0}', vars.PROMO_ENV_NAME || 'test') }}",
             "acrName": "${{ vars.PROMO_AZURE_ACR_NAME }}",
             "sourceRepo": "${{ steps.promo.outputs.sourceRepo }}",
             "targetEnv": "${{ vars.PROMO_ENV_NAME || 'test' }}",
             "targetResourceGroup": "${{ vars.PROMO_AZURE_RESOURCE_GROUP || format('rg-raptor-{0}', vars.PROMO_ENV_NAME || 'test') }}",
             "targetAcrName": "${{ vars.PROMO_AZURE_ACR_NAME }}",
             "targetSubscriptionId": "${{ vars.PROMO_AZURE_SUBSCRIPTION_ID || secrets.AZURE_SUBSCRIPTION_ID }}"}

      - name: Verify dispatch token for cross-repo
        if: success() && steps.promo.outputs.repo && steps.promo.outputs.repo != '' && steps.promo.outputs.repo != github.repository
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.GH_PAT_REPO_DISPATCH }}" ]; then
            echo "Missing secret GH_PAT_REPO_DISPATCH for cross-repo dispatch to ${{ steps.promo.outputs.repo }}." >&2
            echo "Provide a PAT with repo (classic) OR a fine-grained PAT with Actions: Read+write and Contents: Read+write on the target repo." >&2
            exit 1
          fi

      - name: Dispatch promotion (cross-repo)
        if: success() && steps.promo.outputs.repo && steps.promo.outputs.repo != github.repository
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.GH_PAT_REPO_DISPATCH }}
          repository: ${{ steps.promo.outputs.repo }}
          event-type: frontend-image-promote
          client-payload: |
            {"image": "${{ steps.promo.outputs.image }}",
             "resourceGroup": "${{ vars.PROMO_AZURE_RESOURCE_GROUP || format('rg-raptor-{0}', vars.PROMO_ENV_NAME || 'test') }}",
             "acrName": "${{ vars.PROMO_AZURE_ACR_NAME }}",
             "sourceRepo": "${{ steps.promo.outputs.sourceRepo }}",
             "targetEnv": "${{ vars.PROMO_ENV_NAME || 'test' }}",
             "targetResourceGroup": "${{ vars.PROMO_AZURE_RESOURCE_GROUP || format('rg-raptor-{0}', vars.PROMO_ENV_NAME || 'test') }}",
             "targetAcrName": "${{ vars.PROMO_AZURE_ACR_NAME }}",
             "targetSubscriptionId": "${{ vars.PROMO_AZURE_SUBSCRIPTION_ID || secrets.AZURE_SUBSCRIPTION_ID }}"}

      - name: Expose deployment endpoints
        id: expose_endpoints
        run: |
          FQDN=$(azd env get-value frontendFqdn || true)
          # Fallback: if azd env doesn't have it yet, read from the Container App and persist back
          if [ -z "$FQDN" ]; then
            APP_NAME=$(echo "${AZURE_ENV_NAME}-rap-fe" | tr '[:upper:]' '[:lower:]')
            az extension add -n containerapp -y >/dev/null 2>&1 || true
            FQDN=$(az containerapp show -n "$APP_NAME" -g "$AZURE_RESOURCE_GROUP" --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || true)
            if [ -n "$FQDN" ]; then
              azd env set frontendFqdn "$FQDN" >/dev/null || true
            fi
          fi
          echo "frontendFqdn=$FQDN" >> $GITHUB_OUTPUT
          echo "DEPLOY_URL=$FQDN" >> $GITHUB_ENV
          if [ -n "$FQDN" ]; then
            echo "Frontend URL: https://$FQDN"
          else
            echo "Frontend URL not available"
          fi
          {
            echo "### Deployment endpoints"
            echo ""
            if [ -n "$FQDN" ]; then
              echo "- Frontend: https://$FQDN"
            else
              echo "- Frontend: (not available)"
            fi
          } >> $GITHUB_STEP_SUMMARY
