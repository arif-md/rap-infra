name: Infra - Promote Image to Test/Prod

on:
  workflow_dispatch:
    inputs:
      image:
        description: "Full image with digest (e.g., myacr.azurecr.io/raptor/frontend-dev@sha256:...)"
        required: true
  repository_dispatch:
    types: [ frontend-image-promote ]

jobs:
  prepare-and-notify:
    name: Prepare & Notify
    environment: preflight
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: test
      MAIL_SERVER: ${{ secrets.MAIL_SERVER }}
      MAIL_PORT: ${{ secrets.MAIL_PORT }}
      MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
      MAIL_TO: ${{ secrets.MAIL_TO }}
      MAIL_FROM: ${{ secrets.MAIL_FROM }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          allow-no-subscriptions: true

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Resolve inputs
        id: inp
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            SRC_IMAGE='${{ github.event.client_payload.image }}'
          else
            SRC_IMAGE='${{ inputs.image }}'
          fi
          if [ -z "$SRC_IMAGE" ]; then echo "No source image provided" >&2; exit 1; fi
          echo "srcImage=$SRC_IMAGE" >> $GITHUB_OUTPUT

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV=${TARGET_ENV}
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP }}'
          LOC='${{ vars.AZURE_LOCATION }}'
          # Allow passing values from repository_dispatch payload
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            P_RG='${{ github.event.client_payload.resourceGroup }}'
            [ -z "$P_RG" ] && P_RG='${{ github.event.client_payload.rg }}'
            P_LOC='${{ github.event.client_payload.location }}'
            [ -z "$P_LOC" ] && P_LOC='${{ github.event.client_payload.loc }}'
            P_ACR='${{ github.event.client_payload.acrName }}'
            [ -z "$P_ACR" ] && P_ACR='${{ github.event.client_payload.acr }}'
            [ -n "$P_RG" ] && RG="$P_RG"
            [ -n "$P_LOC" ] && LOC="$P_LOC"
            [ -n "$P_ACR" ] && ACR_NAME="$P_ACR"
          fi
          if [ -z "$ACR_NAME" ] || [ -z "$RG" ] || [ -z "$LOC" ]; then
            echo "[prepare-and-notify] AZURE_* variables are not available at repo level (likely defined on the 'test' environment). Proceeding without them."
          fi
          # Fallback RG naming convention if not provided (aligns with ensure-acr scripts)
          if [ -z "$RG" ]; then
            RG="rg-raptor-${TARGET_ENV}"
            echo "[prepare-and-notify] Using fallback resource group: $RG"
          fi
          [ -n "$ACR_NAME" ] && echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          [ -n "$RG" ] && echo "rg=$RG" >> $GITHUB_OUTPUT
          [ -n "$LOC" ] && echo "loc=$LOC" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Capture current deployed image (before promotion)
        id: current
        shell: bash
        run: |
          set -euo pipefail
          ENV='${{ steps.prep.outputs.env }}'
          RG='${{ steps.prep.outputs.rg }}'
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          az extension add -n containerapp -y >/dev/null 2>&1 || true
          CURR_IMG=$(az containerapp show -n "$APP_NAME" -g "$RG" --subscription "$SUB" --query "properties.template.containers[0].image" -o tsv 2>/dev/null || true)
          CURR_DIGEST="${CURR_IMG#*@}"
          echo "image=$CURR_IMG" >> $GITHUB_OUTPUT
          echo "digest=$CURR_DIGEST" >> $GITHUB_OUTPUT

      - name: Generate release notes (diff since last test deploy)
        id: relnotes
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ steps.inp.outputs.srcImage }}'
          NEW_DIGEST="${SRC_IMAGE#*@}"
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          SRC_REPO="${SRC_PATH%@*}"

          # Target ACR/repo context (for previously deployed digest)
          TGT_ENV='${{ steps.prep.outputs.env }}'
          TGT_ACR='${{ steps.prep.outputs.acr }}'
          TGT_REPO="raptor/frontend-${TGT_ENV}"

          # Initialize Azure CLI readiness and subscription early (used by fallbacks below)
          AZ_READY=0
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if az account show -o none >/dev/null 2>&1; then AZ_READY=1; fi

          PREV_IMAGE='${{ steps.current.outputs.image }}'
          PREV_DIGEST='${{ steps.current.outputs.digest }}'
          # If previously deployed image was tag-based (e.g., promoted-12345), resolve its digest from target ACR
          if [ -z "$PREV_DIGEST" ] && [ -n "$PREV_IMAGE" ]; then
            PREV_DOMAIN="${PREV_IMAGE%%/*}"
            PREV_REG=$(echo "$PREV_DOMAIN" | sed 's/\.azurecr\.io$//')
            PREV_PATH="${PREV_IMAGE#*/}"
            PREV_REPO="${PREV_PATH%@*}"
            PREV_TAG="${PREV_PATH#*:}"
            # Only attempt if target ACR context known and prev image points there
            if [ -n "$TGT_ACR" ] && [ "$PREV_REG" = "$TGT_ACR" ] && [ -n "$PREV_TAG" ] && [ "$AZ_READY" -eq 1 ]; then
              # Query the manifest digest for the specific tag
              CANDIDATE=$(az acr repository show-manifests -n "$TGT_ACR" --subscription "$SUB" --repository "$PREV_REPO" --query "[?contains(join(',', tags), '$PREV_TAG')].digest | [0]" -o tsv 2>/dev/null || true)
              if [ -n "$CANDIDATE" ]; then
                PREV_DIGEST="$CANDIDATE"
              fi
            fi
          fi

          # If still no previous digest (e.g., lacking permissions to read Container App), fall back to latest digest in target ACR repo
          if [ -z "$PREV_DIGEST" ] && [ -n "$TGT_ACR" ] && [ -n "$TGT_REPO" ] && [ "$AZ_READY" -eq 1 ]; then
            LATEST=$(az acr repository show-manifests -n "$TGT_ACR" --subscription "$SUB" --repository "$TGT_REPO" --orderby time_desc --top 1 --query "[0].digest" -o tsv 2>/dev/null || true)
            if [ -n "$LATEST" ]; then
              PREV_DIGEST="$LATEST"
            fi
          fi

          echo "Resolved previous image/digest: IMAGE='${PREV_IMAGE:-}' DIGEST='${PREV_DIGEST:-}'"

          # (auth readiness already initialized above)

          get_commit_from_digest() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then return 0; fi
            local TAGS=""
            if [ "$AZ_READY" -eq 1 ]; then
              TAGS=$(az acr manifest show-metadata -n "$reg" --subscription "$SUB" --repository "$repo" --digest "$dig" --query "tags[]" -o tsv 2>/dev/null || true)
              if [ -z "$TAGS" ]; then
                TAGS=$(az acr repository show-manifests -n "$reg" --subscription "$SUB" --repository "$repo" --query "[?digest=='$dig'].tags[]" -o tsv 2>/dev/null || true)
              fi
            fi
            # Extract first hex-looking commit id from tags (supports e.g. "sha-<hex>", "commit-<hex>", or raw hex)
            for t in $TAGS; do
              HEX=$(echo "$t" | grep -oE '[0-9a-f]{7,40}' | head -n1 || true)
              if [ -n "$HEX" ]; then
                echo "$HEX"
                return 0
              fi
            done
            return 0
          }

          NEW_COMMIT_SHORT=""
          PREV_COMMIT_SHORT=""
          if [ "$AZ_READY" -eq 1 ]; then
            # New commit from source (dev) registry/repo
            NEW_COMMIT_SHORT=$(get_commit_from_digest "$SRC_REG_NAME" "$SRC_REPO" "$NEW_DIGEST")
            # Previous commit: try target (test) first, then source (dev) as fallback
            if [ -n "$TGT_ACR" ]; then
              PREV_COMMIT_SHORT=$(get_commit_from_digest "$TGT_ACR" "$TGT_REPO" "$PREV_DIGEST")
            fi
            if [ -z "$PREV_COMMIT_SHORT" ]; then
              PREV_COMMIT_SHORT=$(get_commit_from_digest "$SRC_REG_NAME" "$SRC_REPO" "$PREV_DIGEST")
            fi
          fi

          echo "Resolved commit tags: NEW='$NEW_COMMIT_SHORT' PREV='$PREV_COMMIT_SHORT'"

          git config --global --add safe.directory "$GITHUB_WORKSPACE" || true
          git fetch --prune --unshallow 2>/dev/null || true
          git fetch --all --tags --force

          to_full_sha() {
            local short="$1"
            if [ -z "$short" ]; then return 0; fi
            git rev-parse "$short" 2>/dev/null || true
          }

          NEW_SHA=$(to_full_sha "$NEW_COMMIT_SHORT")
          PREV_SHA=$(to_full_sha "$PREV_COMMIT_SHORT")

          echo "Resolved SHAs: NEW='$NEW_SHA' PREV='$PREV_SHA'"

          FRONTEND_SUBDIR="frontend"
          REPO_URL="https://github.com/${{ github.repository }}"
          BUILD_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          NOTES_FILE="release-notes.md"
          HTML_FILE="release-notes.html"

          {
            echo "## Release notes: Promote frontend to test"
            echo
            echo "- Target environment: test"
            echo "- New image: ${SRC_IMAGE}"
            if [ -n "$PREV_DIGEST" ]; then
              echo "- Previously deployed digest: ${PREV_DIGEST}"
            else
              echo "- Previously deployed digest: (none - first promotion)"
            fi
            echo
            if [ -n "$NEW_SHA" ] && [ -n "$PREV_SHA" ]; then
              echo "### Changes (${PREV_COMMIT_SHORT} → ${NEW_COMMIT_SHORT})"
              echo
              echo "Compare: ${REPO_URL}/compare/${PREV_SHA}...${NEW_SHA}"
              echo
              echo "#### Commits (frontend/ or repo-wide)"
              git log --no-merges --pretty=format:'- %h %s (%an, %ad)' --date=short "${PREV_SHA}..${NEW_SHA}" -- "$FRONTEND_SUBDIR" || true
              if ! git log --no-merges --pretty=format:'- %h %s (%an, %ad)' --date=short "${PREV_SHA}..${NEW_SHA}" -- "$FRONTEND_SUBDIR" | grep -q .; then
                git log --no-merges --pretty=format:'- %h %s (%an, %ad)' --date=short "${PREV_SHA}..${NEW_SHA}" || echo "(no commits found)"
              fi
            elif [ -n "$NEW_SHA" ] && [ -z "$PREV_SHA" ]; then
              echo "First promotion to test with this workflow. Baseline set to ${NEW_COMMIT_SHORT}."
            else
              echo "Could not resolve commit SHAs from image tags. Showing image digests only."
            fi
          } > "$NOTES_FILE"

          {
            echo "<h2>Release notes: Promote frontend to test</h2>"
            echo "<p><strong>Target environment:</strong> test</p>"
            echo "<p><strong>New image:</strong> ${SRC_IMAGE}</p>"
            if [ -n "$PREV_DIGEST" ]; then
              echo "<p><strong>Previously deployed digest:</strong> ${PREV_DIGEST}</p>"
            else
              echo "<p><strong>Previously deployed digest:</strong> (none - first promotion)</p>"
            fi
            echo "<p><a href=\"${BUILD_URL}\">Build details</a></p>"

            if [ -n "$NEW_SHA" ] && [ -n "$PREV_SHA" ]; then
              echo "<h3>List of changes since last successful deployment</h3>"
              echo "<p>Compare: <a href=\"${REPO_URL}/compare/${PREV_SHA}...${NEW_SHA}\">${PREV_COMMIT_SHORT} → ${NEW_COMMIT_SHORT}</a></p>"
              echo "<table border=\"1\" cellspacing=\"0\" cellpadding=\"6\">"
              echo "  <thead><tr><th>Commit Hash</th><th>Author</th><th>Commit Date</th><th>Commit Message</th></tr></thead>"
              echo "  <tbody>"
              COMMITS=$(git log --no-merges --date=short --pretty=format:'%h|%an|%ad|%s' "${PREV_SHA}..${NEW_SHA}" -- "$FRONTEND_SUBDIR" || true)
              if [ -z "$COMMITS" ]; then
                COMMITS=$(git log --no-merges --date=short --pretty=format:'%h|%an|%ad|%s' "${PREV_SHA}..${NEW_SHA}" || true)
              fi
              printf "%s\n" "$COMMITS" | while IFS='|' read -r H A D M; do
                ESC_M=$(python3 -c 'import sys,html; print(html.escape(sys.argv[1]), end="")' "$M")
                echo "    <tr>\n      <td><a href=\"${REPO_URL}/commit/${H}\">${H}</a></td>\n      <td>${A}</td>\n      <td>${D}</td>\n      <td>${ESC_M}</td>\n    </tr>"
              done
              echo "  </tbody>"
              echo "</table>"
            elif [ -n "$NEW_SHA" ] && [ -z "$PREV_SHA" ]; then
              echo "<p>First promotion to test with this workflow. Baseline set to ${NEW_COMMIT_SHORT}.</p>"
            else
              echo "<p>Could not resolve commit SHAs from image tags. Showing image digests only.</p>"
            fi
          } > "$HTML_FILE"

          {
            echo 'body<<EOF'
            cat "$NOTES_FILE"
            echo 'EOF'
            echo 'html<<EOF'
            cat "$HTML_FILE"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

          cat "$NOTES_FILE" >> "$GITHUB_STEP_SUMMARY"
          printf '\n<!-- Rendered HTML changelog -->\n' >> "$GITHUB_STEP_SUMMARY"
          cat "$HTML_FILE" >> "$GITHUB_STEP_SUMMARY"

      - name: Email approver (optional)
        if: ${{ env.MAIL_SERVER && env.MAIL_USERNAME && env.MAIL_PASSWORD && env.MAIL_TO }}
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ env.MAIL_SERVER }}
          server_port: ${{ env.MAIL_PORT || 587 }}
          username: ${{ env.MAIL_USERNAME }}
          password: ${{ env.MAIL_PASSWORD }}
          subject: "[Approval Needed] Promote frontend to test"
          to: ${{ env.MAIL_TO }}
          from: "${{ env.MAIL_FROM || format('github-actions@{0}', github.repository_owner) }}"
          html_body: |-
            <p>A deployment to the '<strong>test</strong>' environment is pending approval.</p>
            <p><strong>Image:</strong> ${{ steps.inp.outputs.srcImage }}<br>
               <strong>Target:</strong> Azure Container Apps (test)</p>
            <p><a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">Build details</a> •
               <a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">Review &amp; approve</a></p>
            ${{ steps.relnotes.outputs.html }}

  promote-test:
    name: Promote to Test
    runs-on: ubuntu-latest
    needs: prepare-and-notify
    environment: test
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: test
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          # Verify Azure CLI is authenticated for this job
          az account show -o none
          az account get-access-token -o none
          # Verify azd is installed and on PATH
          command -v azd >/dev/null 2>&1
          azd version

      - name: Resolve inputs
        id: inp
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            SRC_IMAGE='${{ github.event.client_payload.image }}'
          else
            SRC_IMAGE='${{ inputs.image }}'
          fi
          if [ -z "$SRC_IMAGE" ]; then echo "No source image provided" >&2; exit 1; fi
          echo "srcImage=$SRC_IMAGE" >> $GITHUB_OUTPUT

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          # Prefer environment-specific repo variables; fallback to shared ones
          TARGET_ENV=${TARGET_ENV}
            # Using environment-scoped variables directly (test environment)
            ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
            RG='${{ vars.AZURE_RESOURCE_GROUP }}'
            LOC='${{ vars.AZURE_LOCATION }}'
          if [ -z "$ACR_NAME" ]; then ACR_NAME='${{ vars.AZURE_ACR_NAME }}'; fi
          if [ -z "$RG" ]; then RG='${{ vars.AZURE_RESOURCE_GROUP }}'; fi
          if [ -z "$LOC" ]; then LOC='${{ vars.AZURE_LOCATION }}'; fi
          if [ -z "$ACR_NAME" ] || [ -z "$RG" ] || [ -z "$LOC" ]; then
            echo "Missing AZURE_* variables for test environment. Define AZURE_ACR_NAME_TEST, AZURE_RESOURCE_GROUP_TEST, and AZURE_LOCATION_TEST or shared fallbacks." >&2
            exit 1
          fi
          echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          echo "loc=$LOC" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Ensure target ACR exists
        shell: bash
        run: |
          set -euo pipefail
          ACR='${{ steps.prep.outputs.acr }}'
          RG='${{ steps.prep.outputs.rg }}'
          echo "Ensuring ACR '$ACR' exists in resource group '$RG'"
          az acr show -n "$ACR" >/dev/null 2>&1 || az acr create -n "$ACR" -g "$RG" --sku Standard >/dev/null

      - name: Import manifest into target ACR repo
        id: import
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ steps.inp.outputs.srcImage }}'
          ACR='${{ steps.prep.outputs.acr }}'
          TARGET_REPO="raptor/frontend-${{ steps.prep.outputs.env }}"
          TAG="promoted-${GITHUB_RUN_ID}"
          echo "Importing $SRC_IMAGE -> $ACR/$TARGET_REPO:$TAG"
          az acr import -n "$ACR" --source "$SRC_IMAGE" --image "$TARGET_REPO:$TAG"
          # Extract digest from source string (after @)
          DIGEST="${SRC_IMAGE#*@}"
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      # Note: Release notes and email are handled in prepare-and-notify job

      - name: Prepare azd env
        shell: bash
        run: |
          set -euo pipefail
          azd config set alpha.deployment.stacks on
          azd env new ${{ steps.prep.outputs.env }} --no-prompt || true
          azd env set AZURE_ENV_NAME "${{ steps.prep.outputs.env }}"
          azd env set AZURE_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          azd env set AZURE_LOCATION "${{ steps.prep.outputs.loc }}"
          azd env set AZURE_SUBSCRIPTION_ID "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          azd env set AZURE_ACR_NAME "${{ steps.prep.outputs.acr }}"
          azd env set SERVICE_FRONTEND_IMAGE_NAME "${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false

      - name: Make preprovision hooks executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x ./scripts/ensure-acr.sh

      - name: Deploy to ${{ steps.prep.outputs.env }}
        run: azd up --no-prompt --environment "${{ steps.prep.outputs.env }}"

      - name: Expose deployment endpoints
        id: expose_endpoints
        shell: bash
        run: |
          set -euo pipefail
          FQDN=$(azd env get-value frontendFqdn || true)
          if [ -z "$FQDN" ]; then
            # Fallback: query Container Apps for ingress FQDN
            ENV="${{ steps.prep.outputs.env }}"
            RG="${{ steps.prep.outputs.rg }}"
            APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            az extension add -n containerapp -y >/dev/null 2>&1 || true
            FQDN=$(az containerapp show -n "$APP_NAME" -g "$RG" --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || true)
            if [ -n "$FQDN" ]; then
              azd env set frontendFqdn "$FQDN" >/dev/null || true
            fi
          fi
          echo "frontendFqdn=$FQDN" >> $GITHUB_OUTPUT
          if [ -n "$FQDN" ]; then
            echo "Frontend URL: https://$FQDN"
          else
            echo "Frontend URL not available"
          fi
          {
            echo "### Deployment endpoints"
            echo ""
            if [ -n "$FQDN" ]; then
              echo "- Frontend: https://$FQDN"
            else
              echo "- Frontend: (not available)"
            fi
          } >> $GITHUB_STEP_SUMMARY

  promote-prod:
    name: Promote to Prod
    runs-on: ubuntu-latest
    needs: promote-test
    if: ${{ vars.ENABLE_PROD_PROMOTION == 'true' }}
    environment: prod
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: prod
      MAIL_SERVER: ${{ secrets.MAIL_SERVER }}
      MAIL_PORT: ${{ secrets.MAIL_PORT }}
      MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
      MAIL_TO: ${{ secrets.MAIL_TO }}
      MAIL_FROM: ${{ secrets.MAIL_FROM }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          # Verify Azure CLI is authenticated for this job
          az account show -o none
          az account get-access-token -o none
          # Verify azd is installed and on PATH
          command -v azd >/dev/null 2>&1
          azd version

      - name: Resolve inputs
        id: inp
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            SRC_IMAGE='${{ github.event.client_payload.image }}'
          else
            SRC_IMAGE='${{ inputs.image }}'
          fi
          if [ -z "$SRC_IMAGE" ]; then echo "No source image provided" >&2; exit 1; fi
          echo "srcImage=$SRC_IMAGE" >> $GITHUB_OUTPUT

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV=${TARGET_ENV}
          # Using environment-scoped variables directly (prod environment)
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP }}'
          LOC='${{ vars.AZURE_LOCATION }}'
          if [ -z "$ACR_NAME" ] || [ -z "$RG" ] || [ -z "$LOC" ]; then
            echo "Missing AZURE_* variables for prod environment. Define AZURE_ACR_NAME, AZURE_RESOURCE_GROUP, AZURE_LOCATION in the 'prod' environment." >&2
            exit 1
          fi
          echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          echo "loc=$LOC" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Ensure target ACR exists
        shell: bash
        run: |
          set -euo pipefail
          ACR='${{ steps.prep.outputs.acr }}'
          RG='${{ steps.prep.outputs.rg }}'
          echo "Ensuring ACR '$ACR' exists in resource group '$RG'"
          az acr show -n "$ACR" >/dev/null 2>&1 || az acr create -n "$ACR" -g "$RG" --sku Standard >/dev/null

      - name: Import manifest into target ACR repo
        id: import
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ steps.inp.outputs.srcImage }}'
          ACR='${{ steps.prep.outputs.acr }}'
          TARGET_REPO="raptor/frontend-${{ steps.prep.outputs.env }}"
          TAG="promoted-${GITHUB_RUN_ID}"
          echo "Importing $SRC_IMAGE -> $ACR/$TARGET_REPO:$TAG"
          az acr import -n "$ACR" --source "$SRC_IMAGE" --image "$TARGET_REPO:$TAG"
          DIGEST="${SRC_IMAGE#*@}"
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Prepare azd env
        shell: bash
        run: |
          set -euo pipefail
          azd config set alpha.deployment.stacks on
          azd env new ${{ steps.prep.outputs.env }} --no-prompt || true
          azd env set AZURE_ENV_NAME "${{ steps.prep.outputs.env }}"
          azd env set AZURE_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          azd env set AZURE_LOCATION "${{ steps.prep.outputs.loc }}"
          azd env set AZURE_SUBSCRIPTION_ID "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          azd env set AZURE_ACR_NAME "${{ steps.prep.outputs.acr }}"
          azd env set SERVICE_FRONTEND_IMAGE_NAME "${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false

      - name: Make preprovision hooks executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x ./scripts/ensure-acr.sh

      - name: Deploy to ${{ steps.prep.outputs.env }}
        run: azd up --no-prompt --environment "${{ steps.prep.outputs.env }}"

      - name: Expose deployment endpoints
        id: expose_endpoints
        shell: bash
        run: |
          set -euo pipefail
          FQDN=$(azd env get-value frontendFqdn || true)
          if [ -z "$FQDN" ]; then
            # Fallback: query Container Apps for ingress FQDN
            ENV="${{ steps.prep.outputs.env }}"
            RG="${{ steps.prep.outputs.rg }}"
            APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            az extension add -n containerapp -y >/dev/null 2>&1 || true
            FQDN=$(az containerapp show -n "$APP_NAME" -g "$RG" --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || true)
            if [ -n "$FQDN" ]; then
              azd env set frontendFqdn "$FQDN" >/dev/null || true
            fi
          fi
          echo "frontendFqdn=$FQDN" >> $GITHUB_OUTPUT
          if [ -n "$FQDN" ]; then
            echo "Frontend URL: https://$FQDN"
          else
            echo "Frontend URL not available"
          fi
          {
            echo "### Deployment endpoints"
            echo ""
            if [ -n "$FQDN" ]; then
              echo "- Frontend: https://$FQDN"
            else
              echo "- Frontend: (not available)"
            fi
          } >> $GITHUB_STEP_SUMMARY
