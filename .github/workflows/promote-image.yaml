name: Infra - Promote Image to Higher Environments

on:
  workflow_dispatch:
    inputs:
      image:
        description: "Full image with digest (e.g., myacr.azurecr.io/raptor/frontend-dev@sha256:...)"
        required: true
  repository_dispatch:
    types: [ frontend-image-promote ]

jobs:
  plan:
    name: Determine promotion plan
    runs-on: ubuntu-latest
    outputs:
      srcImage: ${{ steps.resolve.outputs.srcImage }}
      srcRepo: ${{ steps.resolve.outputs.srcRepo }}
      baseEnv: ${{ steps.parse.outputs.baseEnv }}
      run_test: ${{ steps.parse.outputs.run_test }}
      run_train: ${{ steps.parse.outputs.run_train }}
      run_prod: ${{ steps.parse.outputs.run_prod }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve inputs
        id: resolve
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            SRC_IMAGE='${{ github.event.client_payload.image }}'
            SRC_REPO='${{ github.event.client_payload.sourceRepo }}'
          else
            SRC_IMAGE='${{ inputs.image }}'
            SRC_REPO='${{ inputs.sourceRepo }}'
          fi
          if [ -z "$SRC_IMAGE" ]; then echo "No source image provided" >&2; exit 1; fi
          if [ -z "$SRC_REPO" ]; then SRC_REPO='${{ vars.FRONTEND_REPO }}'; fi
          if [ -z "$SRC_REPO" ]; then SRC_REPO='${{ github.repository }}'; fi
          echo "srcImage=$SRC_IMAGE" >> "$GITHUB_OUTPUT"
          echo "srcRepo=$SRC_REPO" >> "$GITHUB_OUTPUT"

      - name: Parse base environment from image
        id: parse
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ steps.resolve.outputs.srcImage }}'
          PATH_PART="${SRC_IMAGE#*/}"
          REPO_PART="${PATH_PART%@*}"
          # Expect repo like raptor/frontend-<env>
          if echo "$REPO_PART" | grep -qE 'frontend-(dev|test|train|prod)'; then
            BASE_ENV=$(printf '%s' "$REPO_PART" | sed -nE 's@.*frontend-((dev|test|train|prod)).*@\1@p')
          else
            # Fallback: default to 'dev'
            BASE_ENV=dev
          fi
          RUN_TEST=false
          RUN_TRAIN=false
          RUN_PROD=false
          case "$BASE_ENV" in
            dev)
              RUN_TEST=true; RUN_TRAIN=true; RUN_PROD=true;;
            test)
              RUN_TRAIN=true; RUN_PROD=true;;
            train)
              RUN_PROD=true;;
            prod)
              :;;
          esac
          echo "baseEnv=$BASE_ENV" >> "$GITHUB_OUTPUT"
          echo "run_test=$RUN_TEST" >> "$GITHUB_OUTPUT"
          echo "run_train=$RUN_TRAIN" >> "$GITHUB_OUTPUT"
          echo "run_prod=$RUN_PROD" >> "$GITHUB_OUTPUT"

  prepare-and-notify-test:
    name: Prepare & Notify (test)
    if: ${{ needs.plan.outputs.run_test == 'true' }}
    needs: plan
    environment: preflight
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: test
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
      SRC_REPO: ${{ needs.plan.outputs.srcRepo }}
      FRONTEND_REPO_READ_TOKEN: ${{ secrets.FRONTEND_REPO_READ_TOKEN }}
      MAIL_SERVER: ${{ secrets.MAIL_SERVER }}
      MAIL_PORT: ${{ secrets.MAIL_PORT }}
      MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
      MAIL_TO: ${{ secrets.MAIL_TO }}
      MAIL_FROM: ${{ secrets.MAIL_FROM }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          allow-no-subscriptions: true

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV='${{ env.TARGET_ENV }}'
          # Prefer explicitly configured values from the GitHub Environment; fall back to conventional names
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP || '' }}'
          if [ -z "$RG" ]; then RG="rg-raptor-${TARGET_ENV}"; fi
          SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          LOC=$(az group show -n "$RG" ${SUB:+--subscription "$SUB"} --query location -o tsv 2>/dev/null || true)
          [ -n "$ACR_NAME" ] && echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          [ -n "$LOC" ] && echo "loc=$LOC" >> $GITHUB_OUTPUT
          [ -n "$SUB" ] && echo "sub=$SUB" >> $GITHUB_OUTPUT
          echo "srcRepo=${{ env.SRC_REPO }}" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Capture current deployed image (before promotion)
        id: current
        shell: bash
        run: |
          set -euo pipefail
          ENV='${{ steps.prep.outputs.env }}'
          RG='${{ steps.prep.outputs.rg }}'
          SUB='${{ steps.prep.outputs.sub }}'
          if [ -z "$SUB" ]; then SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'; fi
          if [ -z "$SUB" ]; then
            SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          az extension add -n containerapp -y >/dev/null 2>&1 || true
          CURR_IMG=$(az containerapp show -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} --query "properties.template.containers[0].image" -o tsv 2>/dev/null || true)
          CURR_DIGEST="${CURR_IMG#*@}"
          # If image isn't in digest form (no '@'), leave digest empty so downstream fallback logic runs
          if [ "$CURR_IMG" = "$CURR_DIGEST" ]; then CURR_DIGEST=""; fi
          echo "image=$CURR_IMG" >> $GITHUB_OUTPUT
          echo "digest=$CURR_DIGEST" >> $GITHUB_OUTPUT
          echo "image=$CURR_IMG"
          echo "digest=$CURR_DIGEST"

      - name: Generate release notes
        id: relnotes
        shell: bash
        env:
          SRC_IMAGE: ${{ env.SRC_IMAGE }}
        run: |
          set -euo pipefail
          # Allow overriding commit table size via repo/env variable
          COMMITS_TABLE_LIMIT='${{ vars.COMMITS_TABLE_LIMIT || 50 }}'
          SRC_IMAGE="$SRC_IMAGE"
          NEW_DIGEST="${SRC_IMAGE#*@}"
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          # IMPORTANT: Do NOT overwrite SRC_REPO (which is the GitHub owner/repo)
          # Derive the ACR repository separately from the image path
          ACR_REPO="${SRC_PATH%@*}"
          TGT_ENV='${{ steps.prep.outputs.env }}'
          TGT_ACR='${{ steps.prep.outputs.acr }}'
          TGT_REPO="raptor/frontend-${TGT_ENV}"
          AZ_READY=0
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if az account show -o none >/dev/null 2>&1; then AZ_READY=1; fi
          PREV_IMAGE='${{ steps.current.outputs.image }}'
          PREV_DIGEST='${{ steps.current.outputs.digest }}'
          if [ -z "$PREV_DIGEST" ] && [ -n "$PREV_IMAGE" ]; then
            PREV_DOMAIN="${PREV_IMAGE%%/*}"
            PREV_REG=$(echo "$PREV_DOMAIN" | sed 's/\.azurecr\.io$//')
            PREV_PATH="${PREV_IMAGE#*/}"
            # Split repo[:tag] or repo@digest into components
            if echo "$PREV_PATH" | grep -q '@'; then
              PREV_REPO="${PREV_PATH%@*}"
              PREV_TAG=""
            else
              PREV_REPO="${PREV_PATH%%:*}"
              if echo "$PREV_PATH" | grep -q ':'; then PREV_TAG="${PREV_PATH#*:}"; else PREV_TAG=""; fi
            fi
            if [ -n "$TGT_ACR" ] && [ "$PREV_REG" = "$TGT_ACR" ] && [ -n "$PREV_TAG" ] && [ "$AZ_READY" -eq 1 ]; then
              CANDIDATE=$(az acr repository show-manifests -n "$TGT_ACR" --subscription "$SUB" --repository "$PREV_REPO" --query "[?contains(join(',', tags), '$PREV_TAG')].digest | [0]" -o tsv 2>/dev/null || true)
              if [ -n "$CANDIDATE" ]; then PREV_DIGEST="$CANDIDATE"; fi
            fi
          fi
          # Derive previous registry/repo from the actual deployed image for accurate commit lookup
          if [ -n "$PREV_IMAGE" ]; then
            PREV_DOMAIN="${PREV_IMAGE%%/*}"
            PREV_REG_NAME=$(echo "$PREV_DOMAIN" | sed 's/\.azurecr\.io$//')
            PREV_PATH="${PREV_IMAGE#*/}"
            PREV_REPO_NAME="${PREV_PATH%@*}"
          fi
          if [ -z "$PREV_DIGEST" ] && [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ] && [ -n "$TGT_ACR" ] && [ -n "$TGT_REPO" ] && [ "$AZ_READY" -eq 1 ]; then
            LATEST=$(az acr repository show-manifests -n "$TGT_ACR" --subscription "$SUB" --repository "$TGT_REPO" --orderby time_desc --top 1 --query "[0].digest" -o tsv 2>/dev/null || true)
            [ -n "$LATEST" ] && PREV_DIGEST="$LATEST"
          fi
          # Resolve commit SHA from OCI labels in ACR for the given repo@digest.
          # - Performs proper ACR OAuth token exchange to obtain a repository-scoped access token.
          # - Handles single-manifest and multi-arch manifest lists by iterating all children.
          # - Checks common alternate label keys and performs a case-insensitive fallback.
          get_commit_from_labels() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then echo ""; return 0; fi
            # Step 1: Get ACR refresh token via az (works across tenants/subscriptions if principal has AcrPull)
            local refresh
            refresh=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            [ -z "$refresh" ] && { echo ""; return 0; }
            # Step 2: Exchange refresh token for repository-scoped access token (pull)
            local scope access base
            scope="repository:${repo}:pull"
            base="https://${reg}.azurecr.io"
            access=$(curl -fsSL -H 'Content-Type: application/x-www-form-urlencoded' \
              --data-urlencode "grant_type=refresh_token" \
              --data-urlencode "service=${reg}.azurecr.io" \
              --data-urlencode "scope=${scope}" \
              --data-urlencode "refresh_token=${refresh}" \
              "$base/oauth2/token" 2>/dev/null | jq -r '.access_token // empty')
            [ -z "$access" ] && { echo ""; return 0; }
            local base="https://${reg}.azurecr.io/v2/${repo}"

            # Helper: fetch a manifest JSON for a digest with appropriate Accept headers
            _fetch_manifest() {
              local digest="$1"
              curl -fsSL \
                -H "Authorization: Bearer $access" \
                -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json' \
                "$base/manifests/$digest" 2>/dev/null || true
            }

            # Helper: extract revision from a single-manifest JSON by reading its config blob labels
            _extract_rev_from_manifest() {
              local manifest_json="$1"
              local cfg
              cfg=$(printf '%s' "$manifest_json" | jq -r '.config.digest // empty')
              [ -z "$cfg" ] && { echo ""; return 0; }
              local cfgJson
              cfgJson=$(curl -fsSL -H "Authorization: Bearer $access" "$base/blobs/$cfg" 2>/dev/null || true)
              [ -z "$cfgJson" ] && { echo ""; return 0; }
              # Try standard and common alternate keys, then case-insensitive search across labels
              local rev
              rev=$(printf '%s' "$cfgJson" | jq -r '
                .config.Labels["org.opencontainers.image.revision"]
                // .config.Labels["org.opencontainers.image.vcs-ref"]
                // empty')
              if [ -z "$rev" ]; then
                # Docker schema sometimes carries labels under container_config
                rev=$(printf '%s' "$cfgJson" | jq -r '
                  .container_config.Labels["org.opencontainers.image.revision"]
                  // .container_config.Labels["org.opencontainers.image.vcs-ref"]
                  // empty')
              fi
              if [ -z "$rev" ]; then
                # Case-insensitive fallback: scan label keys for *revision*
                rev=$(printf '%s' "$cfgJson" | jq -r '
                  (.config.Labels // {})
                  | to_entries
                  | map(select((.key|ascii_downcase) == "org.opencontainers.image.revision"))
                  | .[0].value // empty')
              fi
              printf '%s' "$rev"
            }

            # Fetch the top-level manifest
            local mf
            mf=$(_fetch_manifest "$dig")
            [ -z "$mf" ] && { echo ""; return 0; }
            local media
            media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')

            # If this is a manifest list (multi-arch), iterate each child manifest until a revision label is found
            if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
              local child
              for child in $(printf '%s' "$mf" | jq -r '.manifests[].digest // empty'); do
                [ -z "$child" ] && continue
                local cmf
                cmf=$(_fetch_manifest "$child")
                [ -z "$cmf" ] && continue
                local rev
                rev=$(_extract_rev_from_manifest "$cmf")
                if [ -n "$rev" ]; then printf '%s' "$rev"; return 0; fi
              done
              # Nothing found across children
              echo ""; return 0
            fi

            # Single-manifest path
            _extract_rev_from_manifest "$mf"
          }

          # Debug helper: print where revision might be located for a given repo@digest
          debug_rev() {
            local reg="$1" repo="$2" dig="$3" label="$4"
            echo "[debug] Inspecting $label: reg=$reg repo=$repo digest=${dig:0:25}..."
            if [ -z "$reg" ] || [ -z "$repo" ] || [ -z "$dig" ]; then
              echo "[debug] Skipping ($label): missing inputs"; return 0; fi
            local refresh access mf media base ann cfg cfgJson
            refresh=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            if [ -z "$refresh" ]; then echo "[debug] ($label) token MISSING for $reg"; return 0; fi
            base="https://${reg}.azurecr.io"
            access=$(curl -fsSL -H 'Content-Type: application/x-www-form-urlencoded' \
              --data-urlencode "grant_type=refresh_token" \
              --data-urlencode "service=${reg}.azurecr.io" \
              --data-urlencode "scope=repository:${repo}:pull" \
              --data-urlencode "refresh_token=${refresh}" \
              "$base/oauth2/token" 2>/dev/null | jq -r '.access_token // empty')
            if [ -z "$access" ]; then echo "[debug] ($label) access token exchange failed"; return 0; fi
            local v2base="${base}/v2/${repo}"
            mf=$(curl -fsSL -H "Authorization: Bearer $access" -H 'Accept: application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json, application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$v2base/manifests/$dig" 2>/dev/null || true)
            if [ -z "$mf" ]; then echo "[debug] ($label) manifest fetch empty"; return 0; fi
            media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')
            echo "[debug] ($label) mediaType=$media"
            ann=$(printf '%s' "$mf" | jq -r '.annotations["org.opencontainers.image.revision"] // empty')
            if [ -n "$ann" ]; then echo "[debug] ($label) index.annotation.revision=$ann"; fi
            # If manifest list, iterate a few children
            if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
              local child count=0
              for child in $(printf '%s' "$mf" | jq -r '.manifests[].digest // empty'); do
                count=$((count+1)); [ $count -gt 3 ] && { echo "[debug] ($label) ...truncated child scan"; break; }
                echo "[debug] ($label) child[$count]=${child:0:25}..."
                local cmf; cmf=$(curl -fsSL -H "Authorization: Bearer $access" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$v2base/manifests/$child" 2>/dev/null || true)
                [ -z "$cmf" ] && { echo "[debug] ($label) child manifest empty"; continue; }
                local cfgDig; cfgDig=$(printf '%s' "$cmf" | jq -r '.config.digest // empty')
                echo "[debug] ($label) child cfg=${cfgDig:0:25}..."
                [ -z "$cfgDig" ] && continue
                cfgJson=$(curl -fsSL -H "Authorization: Bearer $access" "$base/v2/${repo}/blobs/$cfgDig" 2>/dev/null || true)
                [ -z "$cfgJson" ] && { echo "[debug] ($label) child cfg blob empty"; continue; }
                local rev1 rev2
                rev1=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
                rev2=$(printf '%s' "$cfgJson" | jq -r '.container_config.Labels["org.opencontainers.image.revision"] // empty')
                if [ -n "$rev1" ] || [ -n "$rev2" ]; then
                  echo "[debug] ($label) revision found in child cfg: ${rev1:-$rev2}"
                  break
                else
                  echo "[debug] ($label) revision not present in child cfg labels"
                fi
              done
              return 0
            fi
            # Single-manifest path
            local cfgDig; cfgDig=$(printf '%s' "$mf" | jq -r '.config.digest // empty')
            echo "[debug] ($label) cfg=${cfgDig:0:25}..."
            [ -z "$cfgDig" ] && return 0
            cfgJson=$(curl -fsSL -H "Authorization: Bearer $access" "$base/v2/${repo}/blobs/$cfgDig" 2>/dev/null || true)
            [ -z "$cfgJson" ] && { echo "[debug] ($label) cfg blob empty"; return 0; }
            local rev1 rev2
            rev1=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
            rev2=$(printf '%s' "$cfgJson" | jq -r '.container_config.Labels["org.opencontainers.image.revision"] // empty')
            if [ -n "$rev1" ] || [ -n "$rev2" ]; then
              echo "[debug] ($label) revision found in cfg: ${rev1:-$rev2}"
            else
              echo "[debug] ($label) revision not present in cfg labels"
            fi
          }
          NEW_COMMIT_SHORT=""
          PREV_COMMIT_SHORT=""
          if [ -n "$NEW_DIGEST" ]; then
            C=$(get_commit_from_labels "$SRC_REG_NAME" "$ACR_REPO" "$NEW_DIGEST")
            [ -n "$C" ] && NEW_COMMIT_SHORT="${C:0:7}" && NEW_SHA="$C"
          fi
          if [ -z "$PREV_COMMIT_SHORT" ] && [ -n "$PREV_DIGEST" ]; then
            # Try the actual previous image registry/repo first
            if [ -n "${PREV_REG_NAME:-}" ] && [ -n "${PREV_REPO_NAME:-}" ]; then C=$(get_commit_from_labels "$PREV_REG_NAME" "$PREV_REPO_NAME" "$PREV_DIGEST"); fi
            # Fall back to target ACR/repo
            if [ -z "${C:-}" ] && [ -n "$TGT_ACR" ]; then C=$(get_commit_from_labels "$TGT_ACR" "$TGT_REPO" "$PREV_DIGEST"); fi
            # Fall back to source image registry/repo
            [ -z "${C:-}" ] && C=$(get_commit_from_labels "$SRC_REG_NAME" "$ACR_REPO" "$PREV_DIGEST")
            [ -n "$C" ] && PREV_COMMIT_SHORT="${C:0:7}" && PREV_SHA="$C"
          fi
          # Fallback: try reading last deployment metadata from Container App tags
          if [ "$AZ_READY" -eq 1 ]; then
            RG='${{ steps.prep.outputs.rg }}'
            APP_NAME=$(echo "${TGT_ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            TAGS_JSON=$(az resource show -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} --resource-type "Microsoft.App/containerApps" --query "tags" -o json 2>/dev/null || true)
            if [ -n "$TAGS_JSON" ] && [ "$TAGS_JSON" != "null" ]; then
              TAGS_DIGEST=$(printf '%s' "$TAGS_JSON" | jq -r '."raptor.lastDigest" // empty')
              TAGS_COMMIT=$(printf '%s' "$TAGS_JSON" | jq -r '."raptor.lastCommit" // empty')
              if [ -z "$PREV_DIGEST" ] && [ -n "$TAGS_DIGEST" ]; then PREV_DIGEST="$TAGS_DIGEST"; fi
              if [ -z "$PREV_COMMIT_SHORT" ] && [ -n "$TAGS_COMMIT" ]; then PREV_COMMIT_SHORT="${TAGS_COMMIT:0:7}"; PREV_SHA="$TAGS_COMMIT"; fi
            fi
          fi
          # If unable to resolve previous commit, KEEP the previous digest; we'll show digest-only notes
          if [ -n "$PREV_DIGEST" ] && [ -z "$PREV_COMMIT_SHORT" ]; then
            echo "[preflight] Previous digest not resolvable to commit; proceeding with digest-only changelog."
          fi
          # Try to expand abbreviated SHAs to full SHAs using GitHub API (improves compare/table reliability)
          OWNER=$(echo "$SRC_REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$SRC_REPO" | cut -d'/' -f2)
          GH_TOKEN_USE=""
          if [ "${{ github.repository }}" = "$SRC_REPO" ]; then GH_TOKEN_USE='${{ github.token }}'; else GH_TOKEN_USE='${{ env.FRONTEND_REPO_READ_TOKEN }}'; fi
          resolve_full_sha() {
            local ref="$1"
            if [ -z "$ref" ] || [ -z "$GH_TOKEN_USE" ]; then echo "$ref"; return 0; fi
            local url="https://api.github.com/repos/${OWNER}/${REPO_NAME}/commits/${ref}"
            local tmp; tmp=$(mktemp)
            local code; code=$(curl -sS -H "Authorization: Bearer $GH_TOKEN_USE" -H "Accept: application/vnd.github+json" -o "$tmp" -w "%{http_code}" "$url" || true)
            if echo "$code" | grep -qE '^(200)$'; then
              jq -r '.sha // empty' < "$tmp"
            else
              echo "$ref"
            fi
          }
          if [ -n "${NEW_SHA:-}" ]; then
            if [ ${#NEW_SHA} -lt 40 ]; then NEW_SHA=$(resolve_full_sha "$NEW_SHA"); fi
          elif [ -n "$NEW_COMMIT_SHORT" ]; then
            NEW_SHA=$(resolve_full_sha "$NEW_COMMIT_SHORT")
          fi
          if [ -n "${PREV_SHA:-}" ]; then
            if [ ${#PREV_SHA} -lt 40 ]; then PREV_SHA=$(resolve_full_sha "$PREV_SHA"); fi
          elif [ -n "$PREV_COMMIT_SHORT" ]; then
            PREV_SHA=$(resolve_full_sha "$PREV_COMMIT_SHORT")
          fi
          # Normalize short displays after expansion
          if [ -n "${NEW_SHA:-}" ]; then NEW_COMMIT_SHORT="${NEW_SHA:0:7}"; fi
          if [ -n "${PREV_SHA:-}" ]; then PREV_COMMIT_SHORT="${PREV_SHA:0:7}"; fi
          REPO_URL="https://github.com/${{ env.SRC_REPO }}"
          BUILD_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          NOTES_FILE="release-notes.md"
          HTML_FILE="release-notes.html"
          {
            echo "## Release notes: Promote frontend to ${TGT_ENV}"
            echo
            echo "- Target environment: ${TGT_ENV}"
            echo "- New image: ${SRC_IMAGE}"
            if [ -n "$PREV_DIGEST" ]; then
              echo "- Previously deployed digest: ${PREV_DIGEST}"
            else
              echo "- Previously deployed digest: (none - first promotion)"
            fi
            echo
            if [ -n "${NEW_SHA:-$NEW_COMMIT_SHORT}" ] && [ -n "${PREV_SHA:-$PREV_COMMIT_SHORT}" ]; then
              if [ "${NEW_SHA:-$NEW_COMMIT_SHORT}" = "${PREV_SHA:-$PREV_COMMIT_SHORT}" ]; then
                echo "### Changes"
                echo
                echo "No code changes detected (same commit: ${NEW_COMMIT_SHORT})."
              else
                echo "### Changes (${PREV_COMMIT_SHORT} → ${NEW_COMMIT_SHORT})"
                echo
                echo "Compare: ${REPO_URL}/compare/${PREV_SHA:-$PREV_COMMIT_SHORT}...${NEW_SHA:-$NEW_COMMIT_SHORT}"
              fi
            else
              echo "Commit SHAs not available from image labels. Showing image digests only."
            fi
          } > "$NOTES_FILE"
          printf '<h2>Release notes: Promote frontend to %s</h2>\n<p><strong>Target environment:</strong> %s</p>\n<p><strong>New image:</strong> %s</p>\n' "$TGT_ENV" "$TGT_ENV" "$SRC_IMAGE" > "$HTML_FILE"
          if [ -n "$PREV_DIGEST" ]; then echo "<p><strong>Previously deployed digest:</strong> ${PREV_DIGEST}</p>" >> "$HTML_FILE"; else echo "<p><strong>Previously deployed digest:</strong> (none - first promotion)</p>" >> "$HTML_FILE"; fi
          echo "<p><a href=\"${BUILD_URL}\">Build details</a></p>" >> "$HTML_FILE"
          # Render a digest-based Changes block for HTML
          if [ -n "$PREV_DIGEST" ]; then
            echo "<h3>Changes</h3>" >> "$HTML_FILE"
            printf '<p>Digest change: <code>%s</code> → <code>%s</code></p>\n' "$PREV_DIGEST" "$NEW_DIGEST" >> "$HTML_FILE"
            if [ -n "${NEW_SHA:-$NEW_COMMIT_SHORT}" ] && [ -n "${PREV_SHA:-$PREV_COMMIT_SHORT}" ]; then
              if [ "${NEW_SHA:-$NEW_COMMIT_SHORT}" = "${PREV_SHA:-$PREV_COMMIT_SHORT}" ]; then
                printf '<p>No code changes detected (same commit: <code>%s</code>).</p>\n' "$NEW_COMMIT_SHORT" >> "$HTML_FILE"
              else
                printf '<p>Compare commits: <a href="%s/compare/%s...%s">%s → %s</a></p>\n' "$REPO_URL" "${PREV_SHA:-$PREV_COMMIT_SHORT}" "${NEW_SHA:-$NEW_COMMIT_SHORT}" "${PREV_COMMIT_SHORT}" "${NEW_COMMIT_SHORT}" >> "$HTML_FILE"
                # Attempt to render a commit log table
                OWNER=$(echo "$SRC_REPO" | cut -d'/' -f1)
                REPO_NAME=$(echo "$SRC_REPO" | cut -d'/' -f2)
                API_URL="https://api.github.com/repos/${OWNER}/${REPO_NAME}/compare/${PREV_SHA:-$PREV_COMMIT_SHORT}...${NEW_SHA:-$NEW_COMMIT_SHORT}"
                # Choose token: default repo token if same repo, else fallback to FRONTEND_REPO_READ_TOKEN
                GH_TOKEN_USE=""
                if [ "${{ github.repository }}" = "$SRC_REPO" ]; then GH_TOKEN_USE='${{ github.token }}'; else GH_TOKEN_USE='${{ env.FRONTEND_REPO_READ_TOKEN }}'; fi
                if [ -n "$GH_TOKEN_USE" ]; then
                  echo "<details><summary>Commit log</summary>" >> "$HTML_FILE"
                  echo '<table border="1" cellpadding="6" cellspacing="0"><thead><tr><th align="left">SHA</th><th align="left">Message</th><th align="left">Author</th><th align="left">Date</th></tr></thead><tbody>' >> "$HTML_FILE"
                  TMP=$(mktemp)
                  HTTP=$(curl -sS -H "Authorization: Bearer $GH_TOKEN_USE" -H "Accept: application/vnd.github+json" -o "$TMP" -w "%{http_code}" "$API_URL" || true)
                  if echo "$HTTP" | grep -qE '^(200|201|204)$'; then
                    JSON=$(cat "$TMP")
                    MAX=${COMMITS_TABLE_LIMIT}
                    TOTAL=$(printf '%s' "$JSON" | jq -r '(.commits // []) | length')
                    printf '%s' "$JSON" | jq -r --argjson max "$MAX" '
                      (.commits // []) | .[0:$max] | .[] | [
                        .sha,
                        (.html_url // ""),
                        (.commit.message | split("\n")[0]),
                        (.commit.author.name // .author.login // "n/a"),
                        (.commit.author.date // .commit.committer.date // "n/a")
                      ] | @tsv' |
                    while IFS=$'\t' read -r SHA URL MSG AUTHOR DATE; do
                      SHORT=${SHA:0:7}
                      # Basic HTML escaping for message
                      MSG_ESC=$(printf '%s' "$MSG" | sed 's/&/&amp;/g; s/</\&lt;/g; s/>/\&gt;/g')
                      if [ -n "$URL" ]; then
                        printf '<tr><td><a href="%s">%s</a></td><td>%s</td><td>%s</td><td><code>%s</code></td></tr>\n' "$URL" "$SHORT" "$MSG_ESC" "$AUTHOR" "$DATE" >> "$HTML_FILE"
                      else
                        printf '<tr><td><code>%s</code></td><td>%s</td><td>%s</td><td><code>%s</code></td></tr>\n' "$SHORT" "$MSG_ESC" "$AUTHOR" "$DATE" >> "$HTML_FILE"
                      fi
                    done
                    if [ "$TOTAL" -gt "$MAX" ]; then
                      echo "</tbody></table>" >> "$HTML_FILE"
                      printf '<p>Showing first %d of %d commits. See the compare link above for the full list.</p>\n' "$MAX" "$TOTAL" >> "$HTML_FILE"
                    else
                      echo "</tbody></table>" >> "$HTML_FILE"
                    fi
                  else
                    echo "[relnotes] Commit API failed ($HTTP) for: $API_URL" >&2
                    echo '<p>(Commit details unavailable; see the compare link above.)</p>' >> "$HTML_FILE"
                  fi
                  echo "</details>" >> "$HTML_FILE"
                else
                  echo "[relnotes] No token available to read ${SRC_REPO}. Skipping commit table." >&2
                fi
              fi
            else
              echo "<p>Commit SHAs not available from image labels.</p>" >> "$HTML_FILE"
            fi
          fi
          {
            echo 'body<<EOF'
            cat "$NOTES_FILE"
            echo 'EOF'
            echo 'html<<EOF'
            cat "$HTML_FILE"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          cat "$NOTES_FILE" >> "$GITHUB_STEP_SUMMARY"
          printf '\n<!-- Rendered HTML changelog -->\n' >> "$GITHUB_STEP_SUMMARY"
          cat "$HTML_FILE" >> "$GITHUB_STEP_SUMMARY"

          # Emit extra debug breadcrumbs to the logs and summary to pinpoint lookup issues
          echo "\n[debug] ===== Label resolution debug ====="
          debug_rev "$SRC_REG_NAME" "$ACR_REPO" "$NEW_DIGEST" "NEW"
          if [ -n "$PREV_DIGEST" ]; then
            if [ -n "${PREV_REG_NAME:-}" ] && [ -n "${PREV_REPO_NAME:-}" ]; then
              debug_rev "$PREV_REG_NAME" "$PREV_REPO_NAME" "$PREV_DIGEST" "PREV(actual)"
            elif [ -n "$TGT_ACR" ]; then
              debug_rev "$TGT_ACR" "$TGT_REPO" "$PREV_DIGEST" "PREV(target)"
            fi
          fi
          echo "[debug] ================================="

      - name: ACR label access diagnostics (preflight)
        if: always()
        shell: bash
        env:
          SRC_IMAGE: ${{ env.SRC_IMAGE }}
        run: |
          set -euo pipefail
          echo "=== ACR label access diagnostics ==="
          TGT_ENV='${{ steps.prep.outputs.env }}'
          TGT_ACR='${{ steps.prep.outputs.acr || '' }}'
          PREV_IMAGE='${{ steps.current.outputs.image || '' }}'
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          if [ -n "$TGT_ACR" ]; then
            echo "Target ACR: $TGT_ACR"
            tok=$(az acr login -n "$TGT_ACR" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            if [ -n "$tok" ]; then echo " - Token: OK"; else echo " - Token: MISSING (no data-plane access)"; fi
          else
            echo "Target ACR: (not set)"
          fi
          echo "Source ACR: $SRC_REG_NAME"
          stok=$(az acr login -n "$SRC_REG_NAME" --expose-token -o tsv --query accessToken 2>/dev/null || true)
          if [ -n "$stok" ]; then echo " - Token: OK"; else echo " - Token: MISSING (no data-plane access)"; fi
          if [ -n "$PREV_IMAGE" ]; then
            PREV_DOMAIN="${PREV_IMAGE%%/*}"
            PREV_REG_NAME=$(echo "$PREV_DOMAIN" | sed 's/\.azurecr\.io$//')
            echo "Previous image ACR: $PREV_REG_NAME"
            ptok=$(az acr login -n "$PREV_REG_NAME" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            if [ -n "$ptok" ]; then echo " - Token: OK"; else echo " - Token: MISSING (no data-plane access)"; fi
          fi
          echo "===================================="

      - name: Check email prerequisites
        shell: bash
        run: |
          set -euo pipefail
          missing=()
          for v in MAIL_SERVER MAIL_USERNAME MAIL_PASSWORD MAIL_TO; do
            if [ -z "${!v:-}" ]; then missing+=("$v"); fi
          done
          if [ ${#missing[@]} -gt 0 ]; then
            echo "Email will be skipped. Missing variables: ${missing[*]}"
          else
            echo "Email prerequisites present."
          fi

      - name: Check environment approvals (required reviewers)
        id: gate
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          ENV='${{ steps.prep.outputs.env }}'
          REPO='${{ github.repository }}'
          URL="https://api.github.com/repos/${REPO}/environments/${ENV}"
          JSON=$(curl -fsS -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" "$URL" || true)
          COUNT=$(printf '%s' "$JSON" | jq -r '[.protection_rules[]? | select(.type=="required_reviewers") | (.reviewers // []) | length] | add // 0')
          NEED="false"; if [ "${COUNT:-0}" -gt 0 ]; then NEED="true"; fi
          echo "needsApproval=$NEED" >> $GITHUB_OUTPUT

      - name: Compose email header
        id: emailhdr
        shell: bash
        run: |
          set -euo pipefail
          ENV='${{ steps.prep.outputs.env }}'
          IMG='${{ env.SRC_IMAGE }}'
          BUILD_URL='${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'
          TARGET="Azure Container Apps ($ENV)"
          if [ '${{ steps.gate.outputs.needsApproval }}' = 'true' ]; then
            SUBJECT="[Approval Needed] Promote frontend to ${ENV}"
            INTRO="A deployment to the '<strong>${ENV}</strong>' environment is pending approval."
            LINKS="<a href=\"${BUILD_URL}\">Build details</a> • <a href=\"${BUILD_URL}\">Review &amp; approve</a>"
          else
            SUBJECT="[Deployment Notice] Promote frontend to ${ENV}"
            INTRO="A deployment to the '<strong>${ENV}</strong>' environment is ready."
            LINKS="<a href=\"${BUILD_URL}\">Build details</a>"
          fi
          echo "subject=$SUBJECT" >> $GITHUB_OUTPUT
          {
            echo 'intro_html<<EOF'
            echo "$INTRO"
            echo 'EOF'
            echo 'links_html<<EOF'
            echo "$LINKS"
            echo 'EOF'
          } >> $GITHUB_OUTPUT

      - name: Email approver/notify (optional)
        if: ${{ env.MAIL_SERVER && env.MAIL_USERNAME && env.MAIL_PASSWORD && env.MAIL_TO }}
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ env.MAIL_SERVER }}
          server_port: ${{ env.MAIL_PORT || 587 }}
          username: ${{ env.MAIL_USERNAME }}
          password: ${{ env.MAIL_PASSWORD }}
          subject: "${{ steps.emailhdr.outputs.subject }}"
          to: ${{ env.MAIL_TO }}
          from: "${{ env.MAIL_FROM || format('github-actions@{0}', github.repository_owner) }}"
          html_body: |-
            <p>${{ steps.emailhdr.outputs.intro_html }}</p>
            <p><strong>Image:</strong> ${{ env.SRC_IMAGE }}<br>
               <strong>Target:</strong> Azure Container Apps (${{ steps.prep.outputs.env }})</p>
            <p>${{ steps.emailhdr.outputs.links_html }}</p>
            ${{ steps.relnotes.outputs.html }}

  promote-to-test:
    name: Promote to test
    if: ${{ needs.plan.outputs.run_test == 'true' }}
    runs-on: ubuntu-latest
    needs: [plan, prepare-and-notify-test]
    environment: test
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: test
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV=${TARGET_ENV}
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP }}'
          if [ -z "$ACR_NAME" ] || [ -z "$RG" ]; then
            echo "Missing AZURE_ACR_NAME or AZURE_RESOURCE_GROUP for '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          LOC=$(az group show -n "$RG" --query location -o tsv 2>/dev/null || true)
          if [ -z "$LOC" ]; then
            echo "Could not resolve location for resource group '$RG' in '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          echo "loc=$LOC" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Ensure target ACR exists
        shell: bash
        run: |
          set -euo pipefail
          ACR='${{ steps.prep.outputs.acr }}'
          # Prefer override RG when provided for cross-RG ACR
          ACR_RG='${{ vars.AZURE_ACR_RESOURCE_GROUP }}'
          if [ -z "$ACR_RG" ]; then ACR_RG='${{ steps.prep.outputs.rg }}'; fi
          echo "Ensuring ACR '$ACR' exists in resource group '$ACR_RG'"
          az acr show -n "$ACR" -g "$ACR_RG" >/dev/null 2>&1 || az acr create -n "$ACR" -g "$ACR_RG" --sku Standard >/dev/null

      - name: Import manifest into target ACR repo
        id: import
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          ACR='${{ steps.prep.outputs.acr }}'
          TARGET_REPO="raptor/frontend-${{ steps.prep.outputs.env }}"
          TAG="promoted-${GITHUB_RUN_ID}"
          echo "Importing $SRC_IMAGE -> $ACR/$TARGET_REPO:$TAG"
          az acr import -n "$ACR" --source "$SRC_IMAGE" --image "$TARGET_REPO:$TAG"
          DIGEST="${SRC_IMAGE#*@}"
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Prepare azd env
        shell: bash
        run: |
          set -euo pipefail
          azd config set alpha.deployment.stacks on
          azd env new ${{ steps.prep.outputs.env }} --no-prompt || true
          azd env set AZURE_ENV_NAME "${{ steps.prep.outputs.env }}"
          azd env set AZURE_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          azd env set AZURE_SUBSCRIPTION_ID "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          azd env set AZURE_ACR_NAME "${{ steps.prep.outputs.acr }}"
          # Pass cross-RG override for ACR when configured
          if [ -n "${{ vars.AZURE_ACR_RESOURCE_GROUP }}" ]; then
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ vars.AZURE_ACR_RESOURCE_GROUP }}"
          else
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          fi
          azd env set SERVICE_FRONTEND_IMAGE_NAME "${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false

      - name: Fast image-only update (skip provision when possible)
        id: fastpath_test
        shell: bash
        run: |
          set -euo pipefail
          APP_NAME=$(echo "${{ steps.prep.outputs.env }}-rap-fe" | tr '[:upper:]' '[:lower:]')
          IMG="${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          DIGEST_PART="${IMG#*@}"
          if [ "$IMG" = "$DIGEST_PART" ]; then
            echo "Image is not digest-form; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          if ! az containerapp show -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" >/dev/null 2>&1; then
            echo "Container App does not exist; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Performing direct image update to: $IMG"
          az containerapp update -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" --image "$IMG"
          echo "didFastPath=true" >> $GITHUB_OUTPUT

      - name: Make preprovision hooks executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x ./scripts/ensure-acr.sh

      - name: Deploy to ${{ steps.prep.outputs.env }}
        if: steps.fastpath_test.outputs.didFastPath != 'true'
        run: azd up --no-prompt --environment "${{ steps.prep.outputs.env }}"

      - name: Expose deployment endpoints
        id: expose_endpoints
        shell: bash
        run: |
          set -euo pipefail
          RAW=$(azd env get-value frontendFqdn 2>/dev/null || true)
          FQDN=$(printf '%s' "$RAW" | tr -d '\r' | head -n1)
          if printf '%s' "$FQDN" | grep -qi '^error:'; then FQDN=""; fi
          if [ -z "$FQDN" ]; then
            ENV="${{ steps.prep.outputs.env }}"
            RG="${{ steps.prep.outputs.rg }}"
            APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            az extension add -n containerapp -y >/dev/null 2>&1 || true
            CA_FQDN=$(az containerapp show -n "$APP_NAME" -g "$RG" --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || true)
            if [ "$CA_FQDN" = "null" ]; then CA_FQDN=""; fi
            FQDN=$(printf '%s' "$CA_FQDN" | tr -d '\r' | head -n1)
            if [ -n "$FQDN" ]; then
              azd env set frontendFqdn "$FQDN" >/dev/null || true
            fi
          fi
          if [ -n "$FQDN" ]; then
            echo "frontendFqdn=$FQDN" >> $GITHUB_OUTPUT
            echo "Frontend URL: https://$FQDN"
          else
            echo "Frontend URL not available"
          fi
          {
            echo "### Deployment endpoints"
            echo ""
            if [ -n "$FQDN" ]; then
              echo "- Frontend: https://$FQDN"
            else
              echo "- Frontend: (not available)"
            fi
          } >> $GITHUB_STEP_SUMMARY

      - name: Persist deployment metadata to tags
        shell: bash
        run: |
          set -euo pipefail
          ENV="${{ steps.prep.outputs.env }}"
          RG="${{ steps.prep.outputs.rg }}"
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if [ -z "$SUB" ]; then SUB=$(az account show --query id -o tsv 2>/dev/null || true); fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          NEW_DIGEST='${{ steps.import.outputs.digest }}'
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          SRC_REPO="${SRC_PATH%@*}"
          get_commit_from_labels() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then echo ""; return 0; fi
            local tok
            tok=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            [ -z "$tok" ] && { echo ""; return 0; }
            local base="https://${reg}.azurecr.io/v2/${repo}"
            local mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json' "$base/manifests/$dig" 2>/dev/null || true)
            [ -z "$mf" ] && { echo ""; return 0; }
            local media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')
            if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
              local child=$(printf '%s' "$mf" | jq -r '.manifests[0].digest // empty')
              [ -n "$child" ] && mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$base/manifests/$child" 2>/dev/null || true)
            fi
            local cfg=$(printf '%s' "$mf" | jq -r '.config.digest // empty')
            [ -z "$cfg" ] && { echo ""; return 0; }
            local cfgJson=$(curl -fsSL -H "Authorization: Bearer $tok" "$base/blobs/$cfg" 2>/dev/null || true)
            [ -z "$cfgJson" ] && { echo ""; return 0; }
            local rev=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
            printf '%s' "$rev"
          }
          NEW_SHA=$(get_commit_from_labels "$SRC_REG_NAME" "$SRC_REPO" "$NEW_DIGEST")
          echo "Updating tags on Container App '$APP_NAME' in RG '$RG'"
          if [ -z "$NEW_DIGEST" ]; then echo "No digest to persist; skipping tag update."; exit 0; fi
          TAG_ARGS=("raptor.lastDigest=${NEW_DIGEST}")
          if [ -n "$NEW_SHA" ]; then TAG_ARGS+=("raptor.lastCommit=${NEW_SHA}"); fi
          az resource tag -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} \
            --resource-type "Microsoft.App/containerApps" \
            --is-incremental \
            --tags "${TAG_ARGS[@]}" >/dev/null

  prepare-and-notify-train:
    name: Prepare & Notify (train)
    if: ${{ needs.plan.outputs.run_train == 'true' }}
    needs: after-test
    environment: preflight
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: train
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
      SRC_REPO: ${{ needs.plan.outputs.srcRepo }}
      FRONTEND_REPO_READ_TOKEN: ${{ secrets.FRONTEND_REPO_READ_TOKEN }}
      MAIL_SERVER: ${{ secrets.MAIL_SERVER }}
      MAIL_PORT: ${{ secrets.MAIL_PORT }}
      MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
      MAIL_TO: ${{ secrets.MAIL_TO }}
      MAIL_FROM: ${{ secrets.MAIL_FROM }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          allow-no-subscriptions: true

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV='${{ env.TARGET_ENV }}'
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP || '' }}'
          if [ -z "$RG" ]; then RG="rg-raptor-${TARGET_ENV}"; fi
          SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          LOC=$(az group show -n "$RG" ${SUB:+--subscription "$SUB"} --query location -o tsv 2>/dev/null || true)
          [ -n "$ACR_NAME" ] && echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          [ -n "$LOC" ] && echo "loc=$LOC" >> $GITHUB_OUTPUT
          [ -n "$SUB" ] && echo "sub=$SUB" >> $GITHUB_OUTPUT
          echo "srcRepo=${{ env.SRC_REPO }}" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Capture current deployed image (before promotion)
        id: current
        shell: bash
        run: |
          set -euo pipefail
          ENV='${{ steps.prep.outputs.env }}'
          RG='${{ steps.prep.outputs.rg }}'
          SUB='${{ steps.prep.outputs.sub }}'
          if [ -z "$SUB" ]; then SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'; fi
          if [ -z "$SUB" ]; then
            SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          az extension add -n containerapp -y >/dev/null 2>&1 || true
          CURR_IMG=$(az containerapp show -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} --query "properties.template.containers[0].image" -o tsv 2>/dev/null || true)
          CURR_DIGEST="${CURR_IMG#*@}"
          if [ "$CURR_IMG" = "$CURR_DIGEST" ]; then CURR_DIGEST=""; fi
          echo "image=$CURR_IMG" >> $GITHUB_OUTPUT
          echo "digest=$CURR_DIGEST" >> $GITHUB_OUTPUT

      - name: Generate release notes
        id: relnotes
        shell: bash
        env:
          SRC_IMAGE: ${{ env.SRC_IMAGE }}
        run: |
          set -euo pipefail
          # Allow overriding commit table size via repo/env variable
          COMMITS_TABLE_LIMIT='${{ vars.COMMITS_TABLE_LIMIT || 50 }}'
          SRC_IMAGE="$SRC_IMAGE"
          NEW_DIGEST="${SRC_IMAGE#*@}"
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          # Do NOT overwrite SRC_REPO (GitHub owner/repo); derive ACR repository separately
          ACR_REPO="${SRC_PATH%@*}"
          TGT_ENV='${{ steps.prep.outputs.env }}'
          TGT_ACR='${{ steps.prep.outputs.acr }}'
          TGT_REPO="raptor/frontend-${TGT_ENV}"
          AZ_READY=0
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if az account show -o none >/dev/null 2>&1; then AZ_READY=1; fi
          PREV_IMAGE='${{ steps.current.outputs.image }}'
          PREV_DIGEST='${{ steps.current.outputs.digest }}'
          if [ -z "$PREV_DIGEST" ] && [ -n "$PREV_IMAGE" ]; then
            PREV_DOMAIN="${PREV_IMAGE%%/*}"
            PREV_REG=$(echo "$PREV_DOMAIN" | sed 's/\.azurecr\.io$//')
            PREV_PATH="${PREV_IMAGE#*/}"
            PREV_REPO="${PREV_PATH%@*}"
            PREV_TAG="${PREV_PATH#*:}"
            if [ -n "$TGT_ACR" ] && [ "$PREV_REG" = "$TGT_ACR" ] && [ -n "$PREV_TAG" ] && [ "$AZ_READY" -eq 1 ]; then
              CANDIDATE=$(az acr repository show-manifests -n "$TGT_ACR" --subscription "$SUB" --repository "$PREV_REPO" --query "[?contains(join(',', tags), '$PREV_TAG')].digest | [0]" -o tsv 2>/dev/null || true)
              if [ -n "$CANDIDATE" ]; then PREV_DIGEST="$CANDIDATE"; fi
            fi
          fi
          if [ -z "$PREV_DIGEST" ] && [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ] && [ -n "$TGT_ACR" ] && [ -n "$TGT_REPO" ] && [ "$AZ_READY" -eq 1 ]; then
            LATEST=$(az acr repository show-manifests -n "$TGT_ACR" --subscription "$SUB" --repository "$TGT_REPO" --orderby time_desc --top 1 --query "[0].digest" -o tsv 2>/dev/null || true)
            [ -n "$LATEST" ] && PREV_DIGEST="$LATEST"
          fi
          get_commit_from_labels() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then echo ""; return 0; fi
            local tok
            tok=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            [ -z "$tok" ] && { echo ""; return 0; }
            local base="https://${reg}.azurecr.io/v2/${repo}"
            local mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json' "$base/manifests/$dig" 2>/dev/null || true)
            [ -z "$mf" ] && { echo ""; return 0; }
            local media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')
            if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
              local child=$(printf '%s' "$mf" | jq -r '.manifests[0].digest // empty')
              [ -n "$child" ] && mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$base/manifests/$child" 2>/dev/null || true)
            fi
            local cfg=$(printf '%s' "$mf" | jq -r '.config.digest // empty')
            [ -z "$cfg" ] && { echo ""; return 0; }
            local cfgJson=$(curl -fsSL -H "Authorization: Bearer $tok" "$base/blobs/$cfg" 2>/dev/null || true)
            [ -z "$cfgJson" ] && { echo ""; return 0; }
            local rev=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
            printf '%s' "$rev"
          }
          NEW_COMMIT_SHORT=""
          PREV_COMMIT_SHORT=""
          if [ -n "$NEW_DIGEST" ]; then
            C=$(get_commit_from_labels "$SRC_REG_NAME" "$ACR_REPO" "$NEW_DIGEST")
            [ -n "$C" ] && NEW_COMMIT_SHORT="${C:0:7}" && NEW_SHA="$C"
          fi
          if [ -z "$PREV_COMMIT_SHORT" ] && [ -n "$PREV_DIGEST" ]; then
            if [ -n "$TGT_ACR" ]; then C=$(get_commit_from_labels "$TGT_ACR" "$TGT_REPO" "$PREV_DIGEST"); fi
            [ -z "${C:-}" ] && C=$(get_commit_from_labels "$SRC_REG_NAME" "$ACR_REPO" "$PREV_DIGEST")
            [ -n "$C" ] && PREV_COMMIT_SHORT="${C:0:7}" && PREV_SHA="$C"
          fi
          # Fallback: try reading last deployment metadata from Container App tags
          if [ "$AZ_READY" -eq 1 ]; then
            RG='${{ steps.prep.outputs.rg }}'
            APP_NAME=$(echo "${TGT_ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            TAGS_JSON=$(az resource show -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} --resource-type "Microsoft.App/containerApps" --query "tags" -o json 2>/dev/null || true)
            if [ -n "$TAGS_JSON" ] && [ "$TAGS_JSON" != "null" ]; then
              TAGS_DIGEST=$(printf '%s' "$TAGS_JSON" | jq -r '."raptor.lastDigest" // empty')
              TAGS_COMMIT=$(printf '%s' "$TAGS_JSON" | jq -r '."raptor.lastCommit" // empty')
              if [ -z "$PREV_DIGEST" ] && [ -n "$TAGS_DIGEST" ]; then PREV_DIGEST="$TAGS_DIGEST"; fi
              if [ -z "$PREV_COMMIT_SHORT" ] && [ -n "$TAGS_COMMIT" ]; then PREV_COMMIT_SHORT="${TAGS_COMMIT:0:7}"; PREV_SHA="$TAGS_COMMIT"; fi
            fi
          fi
          # If still unable to resolve previous commit, treat as first promotion baseline
          if [ -n "$PREV_DIGEST" ] && [ -z "$PREV_COMMIT_SHORT" ]; then
            echo "[preflight] Previous digest not resolvable to commit; treating as first promotion baseline."
            PREV_DIGEST=""
          fi
          # Expand abbreviated SHAs to full via GitHub API to ensure compare/table
          OWNER=$(echo "$SRC_REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$SRC_REPO" | cut -d'/' -f2)
          GH_TOKEN_USE=""
          if [ "${{ github.repository }}" = "$SRC_REPO" ]; then GH_TOKEN_USE='${{ github.token }}'; else GH_TOKEN_USE='${{ env.FRONTEND_REPO_READ_TOKEN }}'; fi
          resolve_full_sha() {
            local ref="$1"
            if [ -z "$ref" ] || [ -z "$GH_TOKEN_USE" ]; then echo "$ref"; return 0; fi
            local url="https://api.github.com/repos/${OWNER}/${REPO_NAME}/commits/${ref}"
            local tmp; tmp=$(mktemp)
            local code; code=$(curl -sS -H "Authorization: Bearer $GH_TOKEN_USE" -H "Accept: application/vnd.github+json" -o "$tmp" -w "%{http_code}" "$url" || true)
            if echo "$code" | grep -qE '^(200)$'; then
              jq -r '.sha // empty' < "$tmp"
            else
              echo "$ref"
            fi
          }
          if [ -n "${NEW_SHA:-}" ]; then
            if [ ${#NEW_SHA} -lt 40 ]; then NEW_SHA=$(resolve_full_sha "$NEW_SHA"); fi
          elif [ -n "$NEW_COMMIT_SHORT" ]; then
            NEW_SHA=$(resolve_full_sha "$NEW_COMMIT_SHORT")
          fi
          if [ -n "${PREV_SHA:-}" ]; then
            if [ ${#PREV_SHA} -lt 40 ]; then PREV_SHA=$(resolve_full_sha "$PREV_SHA"); fi
          elif [ -n "$PREV_COMMIT_SHORT" ]; then
            PREV_SHA=$(resolve_full_sha "$PREV_COMMIT_SHORT")
          fi
          if [ -n "${NEW_SHA:-}" ]; then NEW_COMMIT_SHORT="${NEW_SHA:0:7}"; fi
          if [ -n "${PREV_SHA:-}" ]; then PREV_COMMIT_SHORT="${PREV_SHA:0:7}"; fi
          REPO_URL="https://github.com/${{ env.SRC_REPO }}"
          BUILD_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          NOTES_FILE="release-notes.md"
          HTML_FILE="release-notes.html"
          {
            echo "## Release notes: Promote frontend to ${TGT_ENV}"
            echo
            echo "- Target environment: ${TGT_ENV}"
            echo "- New image: ${SRC_IMAGE}"
            if [ -n "$PREV_DIGEST" ]; then
              echo "- Previously deployed digest: ${PREV_DIGEST}"
            else
              echo "- Previously deployed digest: (none - first promotion)"
            fi
            echo
            if [ -n "${NEW_SHA:-$NEW_COMMIT_SHORT}" ] && [ -n "${PREV_SHA:-$PREV_COMMIT_SHORT}" ]; then
              echo "### Changes (${PREV_COMMIT_SHORT} → ${NEW_COMMIT_SHORT})"
              echo
              echo "Compare: ${REPO_URL}/compare/${PREV_SHA:-$PREV_COMMIT_SHORT}...${NEW_SHA:-$NEW_COMMIT_SHORT}"
            else
              echo "Could not resolve commit SHAs from image tags. Showing image digests only."
            fi
          } > "$NOTES_FILE"
          printf '<h2>Release notes: Promote frontend to %s</h2>\n<p><strong>Target environment:</strong> %s</p>\n<p><strong>New image:</strong> %s</p>\n' "$TGT_ENV" "$TGT_ENV" "$SRC_IMAGE" > "$HTML_FILE"
          if [ -n "$PREV_DIGEST" ]; then echo "<p><strong>Previously deployed digest:</strong> ${PREV_DIGEST}</p>" >> "$HTML_FILE"; else echo "<p><strong>Previously deployed digest:</strong> (none - first promotion)</p>" >> "$HTML_FILE"; fi
          echo "<p><a href=\"${BUILD_URL}\">Build details</a></p>" >> "$HTML_FILE"
          # Commit table (when SHAs resolved and different)
          if [ -n "${NEW_SHA:-$NEW_COMMIT_SHORT}" ] && [ -n "${PREV_SHA:-$PREV_COMMIT_SHORT}" ] && [ "${NEW_SHA:-$NEW_COMMIT_SHORT}" != "${PREV_SHA:-$PREV_COMMIT_SHORT}" ]; then
            OWNER=$(echo "$SRC_REPO" | cut -d'/' -f1)
            REPO_NAME=$(echo "$SRC_REPO" | cut -d'/' -f2)
            API_URL="https://api.github.com/repos/${OWNER}/${REPO_NAME}/compare/${PREV_SHA:-$PREV_COMMIT_SHORT}...${NEW_SHA:-$NEW_COMMIT_SHORT}"
            GH_TOKEN_USE=""
            if [ "${{ github.repository }}" = "$SRC_REPO" ]; then GH_TOKEN_USE='${{ github.token }}'; else GH_TOKEN_USE='${{ env.FRONTEND_REPO_READ_TOKEN }}'; fi
            if [ -n "$GH_TOKEN_USE" ]; then
              echo "<h3>Changes</h3>" >> "$HTML_FILE"
              TMP=$(mktemp)
              HTTP=$(curl -sS -H "Authorization: Bearer $GH_TOKEN_USE" -H "Accept: application/vnd.github+json" -o "$TMP" -w "%{http_code}" "$API_URL" || true)
              if echo "$HTTP" | grep -qE '^(200|201|204)$'; then
                JSON=$(cat "$TMP")
                echo '<table border="1" cellpadding="6" cellspacing="0"><thead><tr><th align="left">SHA</th><th align="left">Message</th><th align="left">Author</th><th align="left">Date</th></tr></thead><tbody>' >> "$HTML_FILE"
                MAX=${COMMITS_TABLE_LIMIT}
                TOTAL=$(printf '%s' "$JSON" | jq -r '(.commits // []) | length')
                printf '%s' "$JSON" | jq -r --argjson max "$MAX" '
                  (.commits // []) | .[0:$max] | .[] | [
                    .sha,
                    (.html_url // ""),
                    (.commit.message | split("\n")[0]),
                    (.commit.author.name // .author.login // "n/a"),
                    (.commit.author.date // .commit.committer.date // "n/a")
                  ] | @tsv' |
                while IFS=$'\t' read -r SHA URL MSG AUTHOR DATE; do
                  SHORT=${SHA:0:7}
                  MSG_ESC=$(printf '%s' "$MSG" | sed 's/&/&amp;/g; s/</\&lt;/g; s/>/\&gt;/g')
                  if [ -n "$URL" ]; then
                    printf '<tr><td><a href="%s">%s</a></td><td>%s</td><td>%s</td><td><code>%s</code></td></tr>\n' "$URL" "$SHORT" "$MSG_ESC" "$AUTHOR" "$DATE" >> "$HTML_FILE"
                  else
                    printf '<tr><td><code>%s</code></td><td>%s</td><td>%s</td><td><code>%s</code></td></tr>\n' "$SHORT" "$MSG_ESC" "$AUTHOR" "$DATE" >> "$HTML_FILE"
                  fi
                done
                echo "</tbody></table>" >> "$HTML_FILE"
                if [ "$TOTAL" -gt "$MAX" ]; then
                  printf '<p>Showing first %d of %d commits. <a href="%s/compare/%s...%s">See more</a>.</p>\n' "$MAX" "$TOTAL" "$REPO_URL" "${PREV_SHA:-$PREV_COMMIT_SHORT}" "${NEW_SHA:-$NEW_COMMIT_SHORT}" >> "$HTML_FILE"
                fi
              else
                echo "[relnotes] Commit API failed ($HTTP) for: $API_URL" >&2
                printf '<p>(Commit details unavailable; <a href="%s/compare/%s...%s">view compare</a>.)</p>\n' "$REPO_URL" "${PREV_SHA:-$PREV_COMMIT_SHORT}" "${NEW_SHA:-$NEW_COMMIT_SHORT}" >> "$HTML_FILE"
              fi
            else
              echo "[relnotes] No token available to read ${SRC_REPO}. Skipping commit table." >&2
            fi
          fi
          {
            echo 'body<<EOF'
            cat "$NOTES_FILE"
            echo 'EOF'
            echo 'html<<EOF'
            cat "$HTML_FILE"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          cat "$NOTES_FILE" >> "$GITHUB_STEP_SUMMARY"
          printf '\n<!-- Rendered HTML changelog -->\n' >> "$GITHUB_STEP_SUMMARY"
          cat "$HTML_FILE" >> "$GITHUB_STEP_SUMMARY"

      - name: Check email prerequisites
        shell: bash
        run: |
          set -euo pipefail
          missing=()
          for v in MAIL_SERVER MAIL_USERNAME MAIL_PASSWORD MAIL_TO; do
            if [ -z "${!v:-}" ]; then missing+=("$v"); fi
          done
          if [ ${#missing[@]} -gt 0 ]; then
            echo "Email will be skipped. Missing variables: ${missing[*]}"
          else
            echo "Email prerequisites present."
          fi

      - name: Email approver (optional)
        if: ${{ env.MAIL_SERVER && env.MAIL_USERNAME && env.MAIL_PASSWORD && env.MAIL_TO }}
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ env.MAIL_SERVER }}
          server_port: ${{ env.MAIL_PORT || 587 }}
          username: ${{ env.MAIL_USERNAME }}
          password: ${{ env.MAIL_PASSWORD }}
          subject: "[Approval Needed] Promote frontend to ${{ steps.prep.outputs.env }}"
          to: ${{ env.MAIL_TO }}
          from: "${{ env.MAIL_FROM || format('github-actions@{0}', github.repository_owner) }}"
          html_body: |-
            <p>A deployment to the '<strong>${{ steps.prep.outputs.env }}</strong>' environment is pending approval.</p>
            <p><strong>Image:</strong> ${{ env.SRC_IMAGE }}<br>
               <strong>Target:</strong> Azure Container Apps (${{ steps.prep.outputs.env }})</p>
            <p><a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">Build details</a> •
               <a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">Review &amp; approve</a></p>
            ${{ steps.relnotes.outputs.html }}

  after-test:
    name: Barrier after test
    if: ${{ always() }}
    needs: [plan, promote-to-test]
    runs-on: ubuntu-latest
    steps:
      - run: echo "Proceeding to train stage"

  promote-to-train:
    name: Promote to train
    if: ${{ needs.plan.outputs.run_train == 'true' }}
    runs-on: ubuntu-latest
    needs: [plan, prepare-and-notify-train]
    environment: train
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: train
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV=${TARGET_ENV}
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP }}'
          if [ -z "$ACR_NAME" ] || [ -z "$RG" ]; then
            echo "Missing AZURE_ACR_NAME or AZURE_RESOURCE_GROUP for '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          LOC=$(az group show -n "$RG" --query location -o tsv 2>/dev/null || true)
          if [ -z "$LOC" ]; then
            echo "Could not resolve location for resource group '$RG' in '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          echo "loc=$LOC" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Ensure target ACR exists
        shell: bash
        run: |
          set -euo pipefail
          ACR='${{ steps.prep.outputs.acr }}'
          ACR_RG='${{ vars.AZURE_ACR_RESOURCE_GROUP }}'
          if [ -z "$ACR_RG" ]; then ACR_RG='${{ steps.prep.outputs.rg }}'; fi
          echo "Ensuring ACR '$ACR' exists in resource group '$ACR_RG'"
          az acr show -n "$ACR" -g "$ACR_RG" >/dev/null 2>&1 || az acr create -n "$ACR" -g "$ACR_RG" --sku Standard >/dev/null

      - name: Import manifest into target ACR repo
        id: import
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          ACR='${{ steps.prep.outputs.acr }}'
          TARGET_REPO="raptor/frontend-${{ steps.prep.outputs.env }}"
          TAG="promoted-${GITHUB_RUN_ID}"
          echo "Importing $SRC_IMAGE -> $ACR/$TARGET_REPO:$TAG"
          az acr import -n "$ACR" --source "$SRC_IMAGE" --image "$TARGET_REPO:$TAG"
          DIGEST="${SRC_IMAGE#*@}"
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Prepare azd env
        shell: bash
        run: |
          set -euo pipefail
          azd config set alpha.deployment.stacks on
          azd env new ${{ steps.prep.outputs.env }} --no-prompt || true
          azd env set AZURE_ENV_NAME "${{ steps.prep.outputs.env }}"
          azd env set AZURE_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          azd env set AZURE_SUBSCRIPTION_ID "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          azd env set AZURE_ACR_NAME "${{ steps.prep.outputs.acr }}"
          if [ -n "${{ vars.AZURE_ACR_RESOURCE_GROUP }}" ]; then
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ vars.AZURE_ACR_RESOURCE_GROUP }}"
          else
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          fi
          azd env set SERVICE_FRONTEND_IMAGE_NAME "${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false

      - name: Fast image-only update (skip provision when possible)
        id: fastpath_train
        shell: bash
        run: |
          set -euo pipefail
          APP_NAME=$(echo "${{ steps.prep.outputs.env }}-rap-fe" | tr '[:upper:]' '[:lower:]')
          IMG="${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          DIGEST_PART="${IMG#*@}"
          if [ "$IMG" = "$DIGEST_PART" ]; then
            echo "Image is not digest-form; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          if ! az containerapp show -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" >/dev/null 2>&1; then
            echo "Container App does not exist; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Performing direct image update to: $IMG"
          az containerapp update -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" --image "$IMG"
          echo "didFastPath=true" >> $GITHUB_OUTPUT

      - name: Make preprovision hooks executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x ./scripts/ensure-acr.sh

      - name: Deploy to ${{ steps.prep.outputs.env }}
        if: steps.fastpath_train.outputs.didFastPath != 'true'
        run: azd up --no-prompt --environment "${{ steps.prep.outputs.env }}"

      - name: Expose deployment endpoints
        id: expose_endpoints
        shell: bash
        run: |
          set -euo pipefail
          RAW=$(azd env get-value frontendFqdn 2>/dev/null || true)
          FQDN=$(printf '%s' "$RAW" | tr -d '\r' | head -n1)
          if printf '%s' "$FQDN" | grep -qi '^error:'; then FQDN=""; fi
          if [ -z "$FQDN" ]; then
            ENV="${{ steps.prep.outputs.env }}"
            RG="${{ steps.prep.outputs.rg }}"
            APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            az extension add -n containerapp -y >/dev/null 2>&1 || true
            CA_FQDN=$(az containerapp show -n "$APP_NAME" -g "$RG" --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || true)
            if [ "$CA_FQDN" = "null" ]; then CA_FQDN=""; fi
            FQDN=$(printf '%s' "$CA_FQDN" | tr -d '\r' | head -n1)
            if [ -n "$FQDN" ]; then
              azd env set frontendFqdn "$FQDN" >/dev/null || true
            fi
          fi
          if [ -n "$FQDN" ]; then
            echo "frontendFqdn=$FQDN" >> $GITHUB_OUTPUT
            echo "Frontend URL: https://$FQDN"
          else
            echo "Frontend URL not available"
          fi
          {
            echo "### Deployment endpoints"
            echo ""
            if [ -n "$FQDN" ]; then
              echo "- Frontend: https://$FQDN"
            else
              echo "- Frontend: (not available)"
            fi
          } >> $GITHUB_STEP_SUMMARY

      - name: Persist deployment metadata to tags
        shell: bash
        run: |
          set -euo pipefail
          ENV="${{ steps.prep.outputs.env }}"
          RG="${{ steps.prep.outputs.rg }}"
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if [ -z "$SUB" ]; then SUB=$(az account show --query id -o tsv 2>/dev/null || true); fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          NEW_DIGEST='${{ steps.import.outputs.digest }}'
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          SRC_REPO="${SRC_PATH%@*}"
          get_commit_from_labels() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then echo ""; return 0; fi
            local tok
            tok=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            [ -z "$tok" ] && { echo ""; return 0; }
            local base="https://${reg}.azurecr.io/v2/${repo}"
            local mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json' "$base/manifests/$dig" 2>/dev/null || true)
            [ -z "$mf" ] && { echo ""; return 0; }
            local media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')
            if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
              local child=$(printf '%s' "$mf" | jq -r '.manifests[0].digest // empty')
              [ -n "$child" ] && mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$base/manifests/$child" 2>/dev/null || true)
            fi
            local cfg=$(printf '%s' "$mf" | jq -r '.config.digest // empty')
            [ -z "$cfg" ] && { echo ""; return 0; }
            local cfgJson=$(curl -fsSL -H "Authorization: Bearer $tok" "$base/blobs/$cfg" 2>/dev/null || true)
            [ -z "$cfgJson" ] && { echo ""; return 0; }
            local rev=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
            printf '%s' "$rev"
          }
          NEW_SHA=$(get_commit_from_labels "$SRC_REG_NAME" "$SRC_REPO" "$NEW_DIGEST")
          echo "Updating tags on Container App '$APP_NAME' in RG '$RG'"
          if [ -z "$NEW_DIGEST" ]; then echo "No digest to persist; skipping tag update."; exit 0; fi
          TAG_ARGS=("raptor.lastDigest=${NEW_DIGEST}")
          if [ -n "$NEW_SHA" ]; then TAG_ARGS+=("raptor.lastCommit=${NEW_SHA}"); fi
          az resource tag -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} \
            --resource-type "Microsoft.App/containerApps" \
            --is-incremental \
            --tags "${TAG_ARGS[@]}" >/dev/null

  after-train:
    name: Barrier after train
    if: ${{ always() }}
    needs: [plan, promote-to-train]
    runs-on: ubuntu-latest
    steps:
      - run: echo "Proceeding to prod stage"

  prepare-and-notify-prod:
    name: Prepare & Notify (prod)
    if: ${{ needs.plan.outputs.run_prod == 'true' }}
    needs: after-train
    environment: preflight
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: prod
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
      SRC_REPO: ${{ needs.plan.outputs.srcRepo }}
      FRONTEND_REPO_READ_TOKEN: ${{ secrets.FRONTEND_REPO_READ_TOKEN }}
      MAIL_SERVER: ${{ secrets.MAIL_SERVER }}
      MAIL_PORT: ${{ secrets.MAIL_PORT }}
      MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
      MAIL_TO: ${{ secrets.MAIL_TO }}
      MAIL_FROM: ${{ secrets.MAIL_FROM }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          allow-no-subscriptions: true

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV='${{ env.TARGET_ENV }}'
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP || '' }}'
          if [ -z "$RG" ]; then RG="rg-raptor-${TARGET_ENV}"; fi
          SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          LOC=$(az group show -n "$RG" ${SUB:+--subscription "$SUB"} --query location -o tsv 2>/dev/null || true)
          [ -n "$ACR_NAME" ] && echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          [ -n "$LOC" ] && echo "loc=$LOC" >> $GITHUB_OUTPUT
          [ -n "$SUB" ] && echo "sub=$SUB" >> $GITHUB_OUTPUT
          echo "srcRepo=${{ env.SRC_REPO }}" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Capture current deployed image (before promotion)
        id: current
        shell: bash
        run: |
          set -euo pipefail
          ENV='${{ steps.prep.outputs.env }}'
          RG='${{ steps.prep.outputs.rg }}'
          SUB='${{ steps.prep.outputs.sub }}'
          if [ -z "$SUB" ]; then SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'; fi
          if [ -z "$SUB" ]; then
            SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          az extension add -n containerapp -y >/dev/null 2>&1 || true
          CURR_IMG=$(az containerapp show -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} --query "properties.template.containers[0].image" -o tsv 2>/dev/null || true)
          CURR_DIGEST="${CURR_IMG#*@}"
          if [ "$CURR_IMG" = "$CURR_DIGEST" ]; then CURR_DIGEST=""; fi
          echo "image=$CURR_IMG" >> $GITHUB_OUTPUT
          echo "digest=$CURR_DIGEST" >> $GITHUB_OUTPUT

      - name: Generate release notes
        id: relnotes
        shell: bash
        env:
          SRC_IMAGE: ${{ env.SRC_IMAGE }}
        run: |
          set -euo pipefail
          # Allow overriding commit table size via repo/env variable
          COMMITS_TABLE_LIMIT='${{ vars.COMMITS_TABLE_LIMIT || 50 }}'
          SRC_IMAGE="$SRC_IMAGE"
          NEW_DIGEST="${SRC_IMAGE#*@}"
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          # Preserve SRC_REPO (GitHub owner/repo) and derive container repo separately
          ACR_REPO="${SRC_PATH%@*}"
          TGT_ENV='${{ steps.prep.outputs.env }}'
          TGT_ACR='${{ steps.prep.outputs.acr }}'
          TGT_REPO="raptor/frontend-${TGT_ENV}"
          AZ_READY=0
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if az account show -o none >/dev/null 2>&1; then AZ_READY=1; fi
          PREV_IMAGE='${{ steps.current.outputs.image }}'
          PREV_DIGEST='${{ steps.current.outputs.digest }}'
          if [ -z "$PREV_DIGEST" ] && [ -n "$PREV_IMAGE" ]; then
            PREV_DOMAIN="${PREV_IMAGE%%/*}"
            PREV_REG=$(echo "$PREV_DOMAIN" | sed 's/\.azurecr\.io$//')
            PREV_PATH="${PREV_IMAGE#*/}"
            PREV_REPO="${PREV_PATH%@*}"
            PREV_TAG="${PREV_PATH#*:}"
            if [ -n "$TGT_ACR" ] && [ "$PREV_REG" = "$TGT_ACR" ] && [ -n "$PREV_TAG" ] && [ "$AZ_READY" -eq 1 ]; then
              CANDIDATE=$(az acr repository show-manifests -n "$TGT_ACR" --subscription "$SUB" --repository "$PREV_REPO" --query "[?contains(join(',', tags), '$PREV_TAG')].digest | [0]" -o tsv 2>/dev/null || true)
              if [ -n "$CANDIDATE" ]; then PREV_DIGEST="$CANDIDATE"; fi
            fi
          fi
          if [ -z "$PREV_DIGEST" ] && [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ] && [ -n "$TGT_ACR" ] && [ -n "$TGT_REPO" ] && [ "$AZ_READY" -eq 1 ]; then
            LATEST=$(az acr repository show-manifests -n "$TGT_ACR" --subscription "$SUB" --repository "$TGT_REPO" --orderby time_desc --top 1 --query "[0].digest" -o tsv 2>/dev/null || true)
            [ -n "$LATEST" ] && PREV_DIGEST="$LATEST"
          fi
          get_commit_from_labels() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then echo ""; return 0; fi
            local tok
            tok=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            [ -z "$tok" ] && { echo ""; return 0; }
            local base="https://${reg}.azurecr.io/v2/${repo}"
            local mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json' "$base/manifests/$dig" 2>/dev/null || true)
            [ -z "$mf" ] && { echo ""; return 0; }
            local media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')
            if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
              local child=$(printf '%s' "$mf" | jq -r '.manifests[0].digest // empty')
              [ -n "$child" ] && mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$base/manifests/$child" 2>/dev/null || true)
            fi
            local cfg=$(printf '%s' "$mf" | jq -r '.config.digest // empty')
            [ -z "$cfg" ] && { echo ""; return 0; }
            local cfgJson=$(curl -fsSL -H "Authorization: Bearer $tok" "$base/blobs/$cfg" 2>/dev/null || true)
            [ -z "$cfgJson" ] && { echo ""; return 0; }
            local rev=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
            printf '%s' "$rev"
          }
          NEW_COMMIT_SHORT=""
          PREV_COMMIT_SHORT=""
          if [ -n "$NEW_DIGEST" ]; then
            C=$(get_commit_from_labels "$SRC_REG_NAME" "$ACR_REPO" "$NEW_DIGEST")
            [ -n "$C" ] && NEW_COMMIT_SHORT="${C:0:7}" && NEW_SHA="$C"
          fi
          if [ -z "$PREV_COMMIT_SHORT" ] && [ -n "$PREV_DIGEST" ]; then
            if [ -n "$TGT_ACR" ]; then C=$(get_commit_from_labels "$TGT_ACR" "$TGT_REPO" "$PREV_DIGEST"); fi
            [ -z "${C:-}" ] && C=$(get_commit_from_labels "$SRC_REG_NAME" "$ACR_REPO" "$PREV_DIGEST")
            [ -n "$C" ] && PREV_COMMIT_SHORT="${C:0:7}" && PREV_SHA="$C"
          fi
          # Fallback: try reading last deployment metadata from Container App tags
          if [ "$AZ_READY" -eq 1 ]; then
            RG='${{ steps.prep.outputs.rg }}'
            APP_NAME=$(echo "${TGT_ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            TAGS_JSON=$(az resource show -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} --resource-type "Microsoft.App/containerApps" --query "tags" -o json 2>/dev/null || true)
            if [ -n "$TAGS_JSON" ] && [ "$TAGS_JSON" != "null" ]; then
              TAGS_DIGEST=$(printf '%s' "$TAGS_JSON" | jq -r '."raptor.lastDigest" // empty')
              TAGS_COMMIT=$(printf '%s' "$TAGS_JSON" | jq -r '."raptor.lastCommit" // empty')
              if [ -z "$PREV_DIGEST" ] && [ -n "$TAGS_DIGEST" ]; then PREV_DIGEST="$TAGS_DIGEST"; fi
              if [ -z "$PREV_COMMIT_SHORT" ] && [ -n "$TAGS_COMMIT" ]; then PREV_COMMIT_SHORT="${TAGS_COMMIT:0:7}"; PREV_SHA="$TAGS_COMMIT"; fi
            fi
          fi
          # If still unable to resolve previous commit, treat as first promotion baseline
          if [ -n "$PREV_DIGEST" ] && [ -z "$PREV_COMMIT_SHORT" ]; then
            echo "[preflight] Previous digest not resolvable to commit; treating as first promotion baseline."
            PREV_DIGEST=""
          fi
          # Expand abbreviated SHAs to full via GitHub API to ensure compare/table
          OWNER=$(echo "$SRC_REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$SRC_REPO" | cut -d'/' -f2)
          GH_TOKEN_USE=""
          if [ "${{ github.repository }}" = "$SRC_REPO" ]; then GH_TOKEN_USE='${{ github.token }}'; else GH_TOKEN_USE='${{ env.FRONTEND_REPO_READ_TOKEN }}'; fi
          resolve_full_sha() {
            local ref="$1"
            if [ -z "$ref" ] || [ -z "$GH_TOKEN_USE" ]; then echo "$ref"; return 0; fi
            local url="https://api.github.com/repos/${OWNER}/${REPO_NAME}/commits/${ref}"
            local tmp; tmp=$(mktemp)
            local code; code=$(curl -sS -H "Authorization: Bearer $GH_TOKEN_USE" -H "Accept: application/vnd.github+json" -o "$tmp" -w "%{http_code}" "$url" || true)
            if echo "$code" | grep -qE '^(200)$'; then
              jq -r '.sha // empty' < "$tmp"
            else
              echo "$ref"
            fi
          }
          if [ -n "${NEW_SHA:-}" ]; then
            if [ ${#NEW_SHA} -lt 40 ]; then NEW_SHA=$(resolve_full_sha "$NEW_SHA"); fi
          elif [ -n "$NEW_COMMIT_SHORT" ]; then
            NEW_SHA=$(resolve_full_sha "$NEW_COMMIT_SHORT")
          fi
          if [ -n "${PREV_SHA:-}" ]; then
            if [ ${#PREV_SHA} -lt 40 ]; then PREV_SHA=$(resolve_full_sha "$PREV_SHA"); fi
          elif [ -n "$PREV_COMMIT_SHORT" ]; then
            PREV_SHA=$(resolve_full_sha "$PREV_COMMIT_SHORT")
          fi
          if [ -n "${NEW_SHA:-}" ]; then NEW_COMMIT_SHORT="${NEW_SHA:0:7}"; fi
          if [ -n "${PREV_SHA:-}" ]; then PREV_COMMIT_SHORT="${PREV_SHA:0:7}"; fi
          REPO_URL="https://github.com/${{ env.SRC_REPO }}"
          BUILD_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          NOTES_FILE="release-notes.md"
          HTML_FILE="release-notes.html"
          {
            echo "## Release notes: Promote frontend to ${TGT_ENV}"
            echo
            echo "- Target environment: ${TGT_ENV}"
            echo "- New image: ${SRC_IMAGE}"
            if [ -n "$PREV_DIGEST" ]; then
              echo "- Previously deployed digest: ${PREV_DIGEST}"
            else
              echo "- Previously deployed digest: (none - first promotion)"
            fi
            echo
            if [ -n "${NEW_SHA:-$NEW_COMMIT_SHORT}" ] && [ -n "${PREV_SHA:-$PREV_COMMIT_SHORT}" ]; then
              echo "### Changes (${PREV_COMMIT_SHORT} → ${NEW_COMMIT_SHORT})"
              echo
              echo "Compare: ${REPO_URL}/compare/${PREV_SHA:-$PREV_COMMIT_SHORT}...${NEW_SHA:-$NEW_COMMIT_SHORT}"
            else
              echo "Could not resolve commit SHAs from image tags. Showing image digests only."
            fi
          } > "$NOTES_FILE"
          printf '<h2>Release notes: Promote frontend to %s</h2>\n<p><strong>Target environment:</strong> %s</p>\n<p><strong>New image:</strong> %s</p>\n' "$TGT_ENV" "$TGT_ENV" "$SRC_IMAGE" > "$HTML_FILE"
          if [ -n "$PREV_DIGEST" ]; then echo "<p><strong>Previously deployed digest:</strong> ${PREV_DIGEST}</p>" >> "$HTML_FILE"; else echo "<p><strong>Previously deployed digest:</strong> (none - first promotion)</p>" >> "$HTML_FILE"; fi
          echo "<p><a href=\"${BUILD_URL}\">Build details</a></p>" >> "$HTML_FILE"
          # Commit table (when SHAs resolved and different)
          if [ -n "${NEW_SHA:-$NEW_COMMIT_SHORT}" ] && [ -n "${PREV_SHA:-$PREV_COMMIT_SHORT}" ] && [ "${NEW_SHA:-$NEW_COMMIT_SHORT}" != "${PREV_SHA:-$PREV_COMMIT_SHORT}" ]; then
            OWNER=$(echo "$SRC_REPO" | cut -d'/' -f1)
            REPO_NAME=$(echo "$SRC_REPO" | cut -d'/' -f2)
            API_URL="https://api.github.com/repos/${OWNER}/${REPO_NAME}/compare/${PREV_SHA:-$PREV_COMMIT_SHORT}...${NEW_SHA:-$NEW_COMMIT_SHORT}"
            GH_TOKEN_USE=""
            if [ "${{ github.repository }}" = "$SRC_REPO" ]; then GH_TOKEN_USE='${{ github.token }}'; else GH_TOKEN_USE='${{ env.FRONTEND_REPO_READ_TOKEN }}'; fi
            if [ -n "$GH_TOKEN_USE" ]; then
              echo "<h3>Changes</h3>" >> "$HTML_FILE"
              TMP=$(mktemp)
              HTTP=$(curl -sS -H "Authorization: Bearer $GH_TOKEN_USE" -H "Accept: application/vnd.github+json" -o "$TMP" -w "%{http_code}" "$API_URL" || true)
              if echo "$HTTP" | grep -qE '^(200|201|204)$'; then
                JSON=$(cat "$TMP")
                echo '<table border="1" cellpadding="6" cellspacing="0"><thead><tr><th align="left">SHA</th><th align="left">Message</th><th align="left">Author</th><th align="left">Date</th></tr></thead><tbody>' >> "$HTML_FILE"
                MAX=${COMMITS_TABLE_LIMIT}
                TOTAL=$(printf '%s' "$JSON" | jq -r '(.commits // []) | length')
                printf '%s' "$JSON" | jq -r --argjson max "$MAX" '
                  (.commits // []) | .[0:$max] | .[] | [
                    .sha,
                    (.html_url // ""),
                    (.commit.message | split("\n")[0]),
                    (.commit.author.name // .author.login // "n/a"),
                    (.commit.author.date // .commit.committer.date // "n/a")
                  ] | @tsv' |
                while IFS=$'\t' read -r SHA URL MSG AUTHOR DATE; do
                  SHORT=${SHA:0:7}
                  MSG_ESC=$(printf '%s' "$MSG" | sed 's/&/&amp;/g; s/</\&lt;/g; s/>/\&gt;/g')
                  if [ -n "$URL" ]; then
                    printf '<tr><td><a href="%s">%s</a></td><td>%s</td><td>%s</td><td><code>%s</code></td></tr>\n' "$URL" "$SHORT" "$MSG_ESC" "$AUTHOR" "$DATE" >> "$HTML_FILE"
                  else
                    printf '<tr><td><code>%s</code></td><td>%s</td><td>%s</td><td><code>%s</code></td></tr>\n' "$SHORT" "$MSG_ESC" "$AUTHOR" "$DATE" >> "$HTML_FILE"
                  fi
                done
                echo "</tbody></table>" >> "$HTML_FILE"
                if [ "$TOTAL" -gt "$MAX" ]; then
                  printf '<p>Showing first %d of %d commits. <a href="%s/compare/%s...%s">See more</a>.</p>\n' "$MAX" "$TOTAL" "$REPO_URL" "${PREV_SHA:-$PREV_COMMIT_SHORT}" "${NEW_SHA:-$NEW_COMMIT_SHORT}" >> "$HTML_FILE"
                fi
              else
                echo "[relnotes] Commit API failed ($HTTP) for: $API_URL" >&2
                printf '<p>(Commit details unavailable; <a href="%s/compare/%s...%s">view compare</a>.)</p>\n' "$REPO_URL" "${PREV_SHA:-$PREV_COMMIT_SHORT}" "${NEW_SHA:-$NEW_COMMIT_SHORT}" >> "$HTML_FILE"
              fi
            else
              echo "[relnotes] No token available to read ${SRC_REPO}. Skipping commit table." >&2
            fi
          fi
          {
            echo 'body<<EOF'
            cat "$NOTES_FILE"
            echo 'EOF'
            echo 'html<<EOF'
            cat "$HTML_FILE"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          cat "$NOTES_FILE" >> "$GITHUB_STEP_SUMMARY"
          printf '\n<!-- Rendered HTML changelog -->\n' >> "$GITHUB_STEP_SUMMARY"
          cat "$HTML_FILE" >> "$GITHUB_STEP_SUMMARY"

      - name: Check email prerequisites
        shell: bash
        run: |
          set -euo pipefail
          missing=()
          for v in MAIL_SERVER MAIL_USERNAME MAIL_PASSWORD MAIL_TO; do
            if [ -z "${!v:-}" ]; then missing+=("$v"); fi
          done
          if [ ${#missing[@]} -gt 0 ]; then
            echo "Email will be skipped. Missing variables: ${missing[*]}"
          else
            echo "Email prerequisites present."
          fi

      - name: Email approver (optional)
        if: ${{ env.MAIL_SERVER && env.MAIL_USERNAME && env.MAIL_PASSWORD && env.MAIL_TO }}
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ env.MAIL_SERVER }}
          server_port: ${{ env.MAIL_PORT || 587 }}
          username: ${{ env.MAIL_USERNAME }}
          password: ${{ env.MAIL_PASSWORD }}
          subject: "[Approval Needed] Promote frontend to ${{ steps.prep.outputs.env }}"
          to: ${{ env.MAIL_TO }}
          from: "${{ env.MAIL_FROM || format('github-actions@{0}', github.repository_owner) }}"
          html_body: |-
            <p>A deployment to the '<strong>${{ steps.prep.outputs.env }}</strong>' environment is pending approval.</p>
            <p><strong>Image:</strong> ${{ env.SRC_IMAGE }}<br>
               <strong>Target:</strong> Azure Container Apps (${{ steps.prep.outputs.env }})</p>
            <p><a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">Build details</a> •
               <a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">Review &amp; approve</a></p>
            ${{ steps.relnotes.outputs.html }}

  promote-to-prod:
    name: Promote to prod
    if: ${{ needs.plan.outputs.run_prod == 'true' }}
    runs-on: ubuntu-latest
    needs: [plan, prepare-and-notify-prod]
    environment: prod
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: prod
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV=${TARGET_ENV}
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP }}'
          if [ -z "$ACR_NAME" ] || [ -z "$RG" ]; then
            echo "Missing AZURE_ACR_NAME or AZURE_RESOURCE_GROUP for '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          LOC=$(az group show -n "$RG" --query location -o tsv 2>/dev/null || true)
          if [ -z "$LOC" ]; then
            echo "Could not resolve location for resource group '$RG' in '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          echo "loc=$LOC" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Ensure target ACR exists
        shell: bash
        run: |
          set -euo pipefail
          ACR='${{ steps.prep.outputs.acr }}'
          ACR_RG='${{ vars.AZURE_ACR_RESOURCE_GROUP }}'
          if [ -z "$ACR_RG" ]; then ACR_RG='${{ steps.prep.outputs.rg }}'; fi
          echo "Ensuring ACR '$ACR' exists in resource group '$ACR_RG'"
          az acr show -n "$ACR" -g "$ACR_RG" >/dev/null 2>&1 || az acr create -n "$ACR" -g "$ACR_RG" --sku Standard >/dev/null

      - name: Import manifest into target ACR repo
        id: import
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          ACR='${{ steps.prep.outputs.acr }}'
          TARGET_REPO="raptor/frontend-${{ steps.prep.outputs.env }}"
          TAG="promoted-${GITHUB_RUN_ID}"
          echo "Importing $SRC_IMAGE -> $ACR/$TARGET_REPO:$TAG"
          az acr import -n "$ACR" --source "$SRC_IMAGE" --image "$TARGET_REPO:$TAG"
          DIGEST="${SRC_IMAGE#*@}"
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Prepare azd env
        shell: bash
        run: |
          set -euo pipefail
          azd config set alpha.deployment.stacks on
          azd env new ${{ steps.prep.outputs.env }} --no-prompt || true
          azd env set AZURE_ENV_NAME "${{ steps.prep.outputs.env }}"
          azd env set AZURE_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          azd env set AZURE_SUBSCRIPTION_ID "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          azd env set AZURE_ACR_NAME "${{ steps.prep.outputs.acr }}"
          if [ -n "${{ vars.AZURE_ACR_RESOURCE_GROUP }}" ]; then
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ vars.AZURE_ACR_RESOURCE_GROUP }}"
          else
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          fi
          azd env set SERVICE_FRONTEND_IMAGE_NAME "${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false

      - name: Fast image-only update (skip provision when possible)
        id: fastpath_prod
        shell: bash
        run: |
          set -euo pipefail
          APP_NAME=$(echo "${{ steps.prep.outputs.env }}-rap-fe" | tr '[:upper:]' '[:lower:]')
          IMG="${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          DIGEST_PART="${IMG#*@}"
          if [ "$IMG" = "$DIGEST_PART" ]; then
            echo "Image is not digest-form; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          if ! az containerapp show -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" >/dev/null 2>&1; then
            echo "Container App does not exist; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Performing direct image update to: $IMG"
          az containerapp update -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" --image "$IMG"
          echo "didFastPath=true" >> $GITHUB_OUTPUT

      - name: Make preprovision hooks executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x ./scripts/ensure-acr.sh

      - name: Deploy to ${{ steps.prep.outputs.env }}
        if: steps.fastpath_prod.outputs.didFastPath != 'true'
        run: azd up --no-prompt --environment "${{ steps.prep.outputs.env }}"

      - name: Expose deployment endpoints
        id: expose_endpoints
        shell: bash
        run: |
          set -euo pipefail
          RAW=$(azd env get-value frontendFqdn 2>/dev/null || true)
          FQDN=$(printf '%s' "$RAW" | tr -d '\r' | head -n1)
          if printf '%s' "$FQDN" | grep -qi '^error:'; then FQDN=""; fi
          if [ -z "$FQDN" ]; then
            ENV="${{ steps.prep.outputs.env }}"
            RG="${{ steps.prep.outputs.rg }}"
            APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            az extension add -n containerapp -y >/dev/null 2>&1 || true
            CA_FQDN=$(az containerapp show -n "$APP_NAME" -g "$RG" --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || true)
            if [ "$CA_FQDN" = "null" ]; then CA_FQDN=""; fi
            FQDN=$(printf '%s' "$CA_FQDN" | tr -d '\r' | head -n1)
            if [ -n "$FQDN" ]; then
              azd env set frontendFqdn "$FQDN" >/dev/null || true
            fi
          fi
          if [ -n "$FQDN" ]; then
            echo "frontendFqdn=$FQDN" >> $GITHUB_OUTPUT
            echo "Frontend URL: https://$FQDN"
          else
            echo "Frontend URL not available"
          fi
          {
            echo "### Deployment endpoints"
            echo ""
            if [ -n "$FQDN" ]; then
              echo "- Frontend: https://$FQDN"
            else
              echo "- Frontend: (not available)"
            fi
          } >> $GITHUB_STEP_SUMMARY

      - name: Persist deployment metadata to tags
        shell: bash
        run: |
          set -euo pipefail
          ENV="${{ steps.prep.outputs.env }}"
          RG="${{ steps.prep.outputs.rg }}"
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if [ -z "$SUB" ]; then SUB=$(az account show --query id -o tsv 2>/dev/null || true); fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          NEW_DIGEST='${{ steps.import.outputs.digest }}'
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          SRC_REPO="${SRC_PATH%@*}"
          get_commit_from_labels() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then echo ""; return 0; fi
            local tok
            tok=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            [ -z "$tok" ] && { echo ""; return 0; }
            local base="https://${reg}.azurecr.io/v2/${repo}"
            local mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json' "$base/manifests/$dig" 2>/dev/null || true)
            [ -z "$mf" ] && { echo ""; return 0; }
            local media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')
            if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
              local child=$(printf '%s' "$mf" | jq -r '.manifests[0].digest // empty')
              [ -n "$child" ] && mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$base/manifests/$child" 2>/dev/null || true)
            fi
            local cfg=$(printf '%s' "$mf" | jq -r '.config.digest // empty')
            [ -z "$cfg" ] && { echo ""; return 0; }
            local cfgJson=$(curl -fsSL -H "Authorization: Bearer $tok" "$base/blobs/$cfg" 2>/dev/null || true)
            [ -z "$cfgJson" ] && { echo ""; return 0; }
            local rev=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
            printf '%s' "$rev"
          }
          NEW_SHA=$(get_commit_from_labels "$SRC_REG_NAME" "$SRC_REPO" "$NEW_DIGEST")
          echo "Updating tags on Container App '$APP_NAME' in RG '$RG'"
          if [ -z "$NEW_DIGEST" ]; then echo "No digest to persist; skipping tag update."; exit 0; fi
          TAG_ARGS=("raptor.lastDigest=${NEW_DIGEST}")
          if [ -n "$NEW_SHA" ]; then TAG_ARGS+=("raptor.lastCommit=${NEW_SHA}"); fi
          az resource tag -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} \
            --resource-type "Microsoft.App/containerApps" \
            --is-incremental \
            --tags "${TAG_ARGS[@]}" >/dev/null

