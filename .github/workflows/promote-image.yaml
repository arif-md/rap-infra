name: Infra - Promote Image to Test/Prod

on:
  workflow_dispatch:
    inputs:
      image:
        description: "Full image with digest (e.g., myacr.azurecr.io/raptor/frontend-dev@sha256:...)"
        required: true
  repository_dispatch:
    types: [ frontend-image-promote ]

jobs:
  promote-test:
    runs-on: ubuntu-latest
    environment: test
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: test
      # Expose mail secrets as masked env so we can use them in 'if' (secrets context is not allowed in if)
      MAIL_SERVER: ${{ secrets.MAIL_SERVER }}
      MAIL_PORT: ${{ secrets.MAIL_PORT }}
      MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
      MAIL_TO: ${{ secrets.MAIL_TO }}
      MAIL_FROM: ${{ secrets.MAIL_FROM }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          # Verify Azure CLI is authenticated for this job
          az account show -o none
          az account get-access-token -o none
          # Verify azd is installed and on PATH
          command -v azd >/dev/null 2>&1
          azd version

      - name: Resolve inputs
        id: inp
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            SRC_IMAGE='${{ github.event.client_payload.image }}'
          else
            SRC_IMAGE='${{ inputs.image }}'
          fi
          if [ -z "$SRC_IMAGE" ]; then echo "No source image provided" >&2; exit 1; fi
          echo "srcImage=$SRC_IMAGE" >> $GITHUB_OUTPUT

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          # Prefer environment-specific repo variables; fallback to shared ones
          TARGET_ENV=${TARGET_ENV}
            # Using environment-scoped variables directly (test environment)
            ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
            RG='${{ vars.AZURE_RESOURCE_GROUP }}'
            LOC='${{ vars.AZURE_LOCATION }}'
          if [ -z "$ACR_NAME" ]; then ACR_NAME='${{ vars.AZURE_ACR_NAME }}'; fi
          if [ -z "$RG" ]; then RG='${{ vars.AZURE_RESOURCE_GROUP }}'; fi
          if [ -z "$LOC" ]; then LOC='${{ vars.AZURE_LOCATION }}'; fi
          if [ -z "$ACR_NAME" ] || [ -z "$RG" ] || [ -z "$LOC" ]; then
            echo "Missing AZURE_* variables for test environment. Define AZURE_ACR_NAME_TEST, AZURE_RESOURCE_GROUP_TEST, and AZURE_LOCATION_TEST or shared fallbacks." >&2
            exit 1
          fi
          echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          echo "loc=$LOC" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Ensure target ACR exists
        shell: bash
        run: |
          set -euo pipefail
          ACR='${{ steps.prep.outputs.acr }}'
          RG='${{ steps.prep.outputs.rg }}'
          echo "Ensuring ACR '$ACR' exists in resource group '$RG'"
          az acr show -n "$ACR" >/dev/null 2>&1 || az acr create -n "$ACR" -g "$RG" --sku Standard >/dev/null

      - name: Import manifest into target ACR repo
        id: import
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ steps.inp.outputs.srcImage }}'
          ACR='${{ steps.prep.outputs.acr }}'
          TARGET_REPO="raptor/frontend-${{ steps.prep.outputs.env }}"
          TAG="promoted-${GITHUB_RUN_ID}"
          echo "Importing $SRC_IMAGE -> $ACR/$TARGET_REPO:$TAG"
          az acr import -n "$ACR" --source "$SRC_IMAGE" --image "$TARGET_REPO:$TAG"
          # Extract digest from source string (after @)
          DIGEST="${SRC_IMAGE#*@}"
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Capture current deployed image (before promotion)
        id: current
        shell: bash
        run: |
          set -euo pipefail
          ENV='${{ steps.prep.outputs.env }}'
          RG='${{ steps.prep.outputs.rg }}'
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          az extension add -n containerapp -y >/dev/null 2>&1 || true
          CURR_IMG=$(az containerapp show -n "$APP_NAME" -g "$RG" --query "properties.template.containers[0].image" -o tsv 2>/dev/null || true)
          CURR_DIGEST="${CURR_IMG#*@}"
          echo "image=$CURR_IMG" >> $GITHUB_OUTPUT
          echo "digest=$CURR_DIGEST" >> $GITHUB_OUTPUT

      - name: Generate release notes (diff since last test deploy)
        id: relnotes
        shell: bash
        run: |
          set -euo pipefail
          # New (to be promoted) image digest and source registry/repo
          SRC_IMAGE='${{ steps.inp.outputs.srcImage }}'
          NEW_DIGEST="${SRC_IMAGE#*@}"
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          SRC_REPO="${SRC_PATH%@*}"

          # Previously deployed digest from test (may be empty on first deploy)
          PREV_DIGEST='${{ steps.current.outputs.digest }}'

          # Helper to get a commit-like tag from ACR manifest tags
          get_commit_from_digest() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then return 0; fi
            # Try manifest show-metadata (preferred)
            TAGS=$(az acr manifest show-metadata -n "$reg" --repository "$repo" --digest "$dig" --query "tags[]" -o tsv 2>/dev/null || true)
            if [ -z "$TAGS" ]; then
              # Fallback to show-manifests and filter by digest
              TAGS=$(az acr repository show-manifests -n "$reg" --repository "$repo" --query "[?digest=='$dig'].tags[]" -o tsv 2>/dev/null || true)
            fi
            echo "$TAGS" | tr '\t' '\n' | grep -E '^[0-9a-f]{7,40}$' | head -n1 || true
          }

          NEW_COMMIT_SHORT=$(get_commit_from_digest "$SRC_REG_NAME" "$SRC_REPO" "$NEW_DIGEST")
          PREV_COMMIT_SHORT=$(get_commit_from_digest "$SRC_REG_NAME" "$SRC_REPO" "$PREV_DIGEST")

          # Ensure we have history to resolve SHAs
          git config --global --add safe.directory "$GITHUB_WORKSPACE" || true
          git fetch --prune --unshallow 2>/dev/null || true
          git fetch --all --tags --force

          to_full_sha() {
            local short="$1"
            if [ -z "$short" ]; then return 0; fi
            git rev-parse "$short" 2>/dev/null || true
          }

          NEW_SHA=$(to_full_sha "$NEW_COMMIT_SHORT")
          PREV_SHA=$(to_full_sha "$PREV_COMMIT_SHORT")

          FRONTEND_SUBDIR="frontend"
          REPO_URL="https://github.com/${{ github.repository }}"
          BUILD_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          NOTES_FILE="release-notes.md"
          HTML_FILE="release-notes.html"

          {
            echo "## Release notes: Promote frontend to test"
            echo
            echo "- Target environment: test"
            echo "- New image: ${SRC_IMAGE}"
            if [ -n "$PREV_DIGEST" ]; then
              echo "- Previously deployed digest: ${PREV_DIGEST}"
            else
              echo "- Previously deployed digest: (none - first promotion)"
            fi
            echo
            if [ -n "$NEW_SHA" ] && [ -n "$PREV_SHA" ]; then
              echo "### Changes (${PREV_COMMIT_SHORT} → ${NEW_COMMIT_SHORT})"
              echo
              echo "Compare: ${REPO_URL}/compare/${PREV_SHA}...${NEW_SHA}"
              echo
              echo "#### Commits in frontend/"
              git log --no-merges --pretty=format:'- %h %s (%an, %ad)' --date=short "${PREV_SHA}..${NEW_SHA}" -- "$FRONTEND_SUBDIR" || echo "(no path-specific changes in frontend/)"
            elif [ -n "$NEW_SHA" ] && [ -z "$PREV_SHA" ]; then
              echo "First promotion to test with this workflow. Baseline set to ${NEW_COMMIT_SHORT}."
            else
              echo "Could not resolve commit SHAs from image tags. Showing image digests only."
            fi
          } > "$NOTES_FILE"

          # Build an HTML version with a tabular changelog
          {
            echo "<h2>Release notes: Promote frontend to test</h2>"
            echo "<p><strong>Target environment:</strong> test</p>"
            echo "<p><strong>New image:</strong> ${SRC_IMAGE}</p>"
            if [ -n "$PREV_DIGEST" ]; then
              echo "<p><strong>Previously deployed digest:</strong> ${PREV_DIGEST}</p>"
            else
              echo "<p><strong>Previously deployed digest:</strong> (none - first promotion)</p>"
            fi
            echo "<p><a href=\"${BUILD_URL}\">Build details</a></p>"

            if [ -n "$NEW_SHA" ] && [ -n "$PREV_SHA" ]; then
              echo "<h3>List of changes since last successful deployment</h3>"
              echo "<p>Compare: <a href=\"${REPO_URL}/compare/${PREV_SHA}...${NEW_SHA}\">${PREV_COMMIT_SHORT} → ${NEW_COMMIT_SHORT}</a></p>"
              echo "<table border=\"1\" cellspacing=\"0\" cellpadding=\"6\">"
              echo "  <thead><tr><th>Commit Hash</th><th>Author</th><th>Commit Date</th><th>Commit Message</th></tr></thead>"
              echo "  <tbody>"
              while IFS='|' read -r H A D M; do
                # Escape message to safe HTML using Python one-liner (avoids here-doc parsing issues)
                ESC_M=$(python3 -c 'import sys,html; print(html.escape(sys.argv[1]), end="")' "$M")
                echo "    <tr>\n      <td><a href=\"${REPO_URL}/commit/${H}\">${H}</a></td>\n      <td>${A}</td>\n      <td>${D}</td>\n      <td>${ESC_M}</td>\n    </tr>"
              done < <(git log --no-merges --date=short --pretty=format:'%h|%an|%ad|%s' "${PREV_SHA}..${NEW_SHA}" -- "$FRONTEND_SUBDIR" || true)
              echo "  </tbody>"
              echo "</table>"
            elif [ -n "$NEW_SHA" ] && [ -z "$PREV_SHA" ]; then
              echo "<p>First promotion to test with this workflow. Baseline set to ${NEW_COMMIT_SHORT}.</p>"
            else
              echo "<p>Could not resolve commit SHAs from image tags. Showing image digests only.</p>"
            fi
          } > "$HTML_FILE"

          echo "Generated release notes:"; echo "-------------------------"; cat "$NOTES_FILE"; echo "\n-------------------------"

          # Set output for later steps (email) and append to job summary
          {
            echo 'body<<EOF'
            cat "$NOTES_FILE"
            echo 'EOF'
            echo 'html<<EOF'
            cat "$HTML_FILE"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          cat "$NOTES_FILE" >> "$GITHUB_STEP_SUMMARY"
          printf '\n<!-- Rendered HTML changelog -->\n' >> "$GITHUB_STEP_SUMMARY"
          cat "$HTML_FILE" >> "$GITHUB_STEP_SUMMARY"

      - name: Email approver (optional)
        if: ${{ env.MAIL_SERVER && env.MAIL_USERNAME && env.MAIL_PASSWORD && env.MAIL_TO }}
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ env.MAIL_SERVER }}
          server_port: ${{ env.MAIL_PORT || 587 }}
          username: ${{ env.MAIL_USERNAME }}
          password: ${{ env.MAIL_PASSWORD }}
          subject: "[Approval Needed] Promote frontend to test"
          to: ${{ env.MAIL_TO }}
          from: "${{ env.MAIL_FROM || format('github-actions@{0}', github.repository_owner) }}"
          html_body: |-
            <p>A deployment to the '<strong>test</strong>' environment is pending approval.</p>
            <p><strong>Image:</strong> ${{ steps.inp.outputs.srcImage }}<br>
               <strong>Target:</strong> Azure Container Apps (test)</p>
            <p><a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">Build details</a> •
               <a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">Review &amp; approve</a></p>
            ${{ steps.relnotes.outputs.html }}

      - name: Prepare azd env
        shell: bash
        run: |
          set -euo pipefail
          azd config set alpha.deployment.stacks on
          azd env new ${{ steps.prep.outputs.env }} --no-prompt || true
          azd env set AZURE_ENV_NAME "${{ steps.prep.outputs.env }}"
          azd env set AZURE_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          azd env set AZURE_LOCATION "${{ steps.prep.outputs.loc }}"
          azd env set AZURE_SUBSCRIPTION_ID "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          azd env set AZURE_ACR_NAME "${{ steps.prep.outputs.acr }}"
          azd env set SERVICE_FRONTEND_IMAGE_NAME "${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false

      - name: Make preprovision hooks executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x ./scripts/ensure-acr.sh

      - name: Deploy to ${{ steps.prep.outputs.env }}
        run: azd up --no-prompt --environment "${{ steps.prep.outputs.env }}"

      - name: Expose deployment endpoints
        id: expose_endpoints
        shell: bash
        run: |
          set -euo pipefail
          FQDN=$(azd env get-value frontendFqdn || true)
          if [ -z "$FQDN" ]; then
            # Fallback: query Container Apps for ingress FQDN
            ENV="${{ steps.prep.outputs.env }}"
            RG="${{ steps.prep.outputs.rg }}"
            APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            az extension add -n containerapp -y >/dev/null 2>&1 || true
            FQDN=$(az containerapp show -n "$APP_NAME" -g "$RG" --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || true)
            if [ -n "$FQDN" ]; then
              azd env set frontendFqdn "$FQDN" >/dev/null || true
            fi
          fi
          echo "frontendFqdn=$FQDN" >> $GITHUB_OUTPUT
          if [ -n "$FQDN" ]; then
            echo "Frontend URL: https://$FQDN"
          else
            echo "Frontend URL not available"
          fi
          {
            echo "### Deployment endpoints"
            echo ""
            if [ -n "$FQDN" ]; then
              echo "- Frontend: https://$FQDN"
            else
              echo "- Frontend: (not available)"
            fi
          } >> $GITHUB_STEP_SUMMARY

  promote-prod:
    runs-on: ubuntu-latest
    needs: promote-test
    if: ${{ vars.ENABLE_PROD_PROMOTION == 'true' }}
    environment: prod
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: prod
      MAIL_SERVER: ${{ secrets.MAIL_SERVER }}
      MAIL_PORT: ${{ secrets.MAIL_PORT }}
      MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
      MAIL_TO: ${{ secrets.MAIL_TO }}
      MAIL_FROM: ${{ secrets.MAIL_FROM }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          # Verify Azure CLI is authenticated for this job
          az account show -o none
          az account get-access-token -o none
          # Verify azd is installed and on PATH
          command -v azd >/dev/null 2>&1
          azd version

      - name: Resolve inputs
        id: inp
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            SRC_IMAGE='${{ github.event.client_payload.image }}'
          else
            SRC_IMAGE='${{ inputs.image }}'
          fi
          if [ -z "$SRC_IMAGE" ]; then echo "No source image provided" >&2; exit 1; fi
          echo "srcImage=$SRC_IMAGE" >> $GITHUB_OUTPUT

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV=${TARGET_ENV}
          # Using environment-scoped variables directly (prod environment)
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP }}'
          LOC='${{ vars.AZURE_LOCATION }}'
          if [ -z "$ACR_NAME" ] || [ -z "$RG" ] || [ -z "$LOC" ]; then
            echo "Missing AZURE_* variables for prod environment. Define AZURE_ACR_NAME, AZURE_RESOURCE_GROUP, AZURE_LOCATION in the 'prod' environment." >&2
            exit 1
          fi
          echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          echo "loc=$LOC" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Ensure target ACR exists
        shell: bash
        run: |
          set -euo pipefail
          ACR='${{ steps.prep.outputs.acr }}'
          RG='${{ steps.prep.outputs.rg }}'
          echo "Ensuring ACR '$ACR' exists in resource group '$RG'"
          az acr show -n "$ACR" >/dev/null 2>&1 || az acr create -n "$ACR" -g "$RG" --sku Standard >/dev/null

      - name: Import manifest into target ACR repo
        id: import
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ steps.inp.outputs.srcImage }}'
          ACR='${{ steps.prep.outputs.acr }}'
          TARGET_REPO="raptor/frontend-${{ steps.prep.outputs.env }}"
          TAG="promoted-${GITHUB_RUN_ID}"
          echo "Importing $SRC_IMAGE -> $ACR/$TARGET_REPO:$TAG"
          az acr import -n "$ACR" --source "$SRC_IMAGE" --image "$TARGET_REPO:$TAG"
          DIGEST="${SRC_IMAGE#*@}"
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Prepare azd env
        shell: bash
        run: |
          set -euo pipefail
          azd config set alpha.deployment.stacks on
          azd env new ${{ steps.prep.outputs.env }} --no-prompt || true
          azd env set AZURE_ENV_NAME "${{ steps.prep.outputs.env }}"
          azd env set AZURE_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          azd env set AZURE_LOCATION "${{ steps.prep.outputs.loc }}"
          azd env set AZURE_SUBSCRIPTION_ID "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          azd env set AZURE_ACR_NAME "${{ steps.prep.outputs.acr }}"
          azd env set SERVICE_FRONTEND_IMAGE_NAME "${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false

      - name: Make preprovision hooks executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x ./scripts/ensure-acr.sh

      - name: Deploy to ${{ steps.prep.outputs.env }}
        run: azd up --no-prompt --environment "${{ steps.prep.outputs.env }}"

      - name: Expose deployment endpoints
        id: expose_endpoints
        shell: bash
        run: |
          set -euo pipefail
          FQDN=$(azd env get-value frontendFqdn || true)
          if [ -z "$FQDN" ]; then
            # Fallback: query Container Apps for ingress FQDN
            ENV="${{ steps.prep.outputs.env }}"
            RG="${{ steps.prep.outputs.rg }}"
            APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            az extension add -n containerapp -y >/dev/null 2>&1 || true
            FQDN=$(az containerapp show -n "$APP_NAME" -g "$RG" --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || true)
            if [ -n "$FQDN" ]; then
              azd env set frontendFqdn "$FQDN" >/dev/null || true
            fi
          fi
          echo "frontendFqdn=$FQDN" >> $GITHUB_OUTPUT
          if [ -n "$FQDN" ]; then
            echo "Frontend URL: https://$FQDN"
          else
            echo "Frontend URL not available"
          fi
          {
            echo "### Deployment endpoints"
            echo ""
            if [ -n "$FQDN" ]; then
              echo "- Frontend: https://$FQDN"
            else
              echo "- Frontend: (not available)"
            fi
          } >> $GITHUB_STEP_SUMMARY
