name: Infra - Promote Image to Higher Environments

on:
  workflow_dispatch:
    inputs:
      image:
        description: "Full image with digest (e.g., myacr.azurecr.io/raptor/frontend-dev@sha256:...)"
        required: true
  repository_dispatch:
    types: [ frontend-image-promote ]

jobs:
  plan:
    name: Determine promotion plan
    runs-on: ubuntu-latest
    outputs:
      srcImage: ${{ steps.resolve.outputs.srcImage }}
      srcRepo: ${{ steps.resolve.outputs.srcRepo }}
      baseEnv: ${{ steps.parse.outputs.baseEnv }}
      run_test: ${{ steps.parse.outputs.run_test }}
      run_train: ${{ steps.parse.outputs.run_train }}
      run_prod: ${{ steps.parse.outputs.run_prod }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve inputs
        id: resolve
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            SRC_IMAGE='${{ github.event.client_payload.image }}'
            SRC_REPO='${{ github.event.client_payload.sourceRepo }}'
          else
            SRC_IMAGE='${{ inputs.image }}'
            SRC_REPO='${{ inputs.sourceRepo }}'
          fi
          if [ -z "$SRC_IMAGE" ]; then echo "No source image provided" >&2; exit 1; fi
          if [ -z "$SRC_REPO" ]; then SRC_REPO='${{ vars.FRONTEND_REPO }}'; fi
          if [ -z "$SRC_REPO" ]; then SRC_REPO='${{ github.repository }}'; fi
          echo "srcImage=$SRC_IMAGE" >> "$GITHUB_OUTPUT"
          echo "srcRepo=$SRC_REPO" >> "$GITHUB_OUTPUT"

      - name: Parse base environment from image
        id: parse
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ steps.resolve.outputs.srcImage }}'
          PATH_PART="${SRC_IMAGE#*/}"
          REPO_PART="${PATH_PART%@*}"
          # Expect repo like raptor/frontend-<env>
          if echo "$REPO_PART" | grep -qE 'frontend-(dev|test|train|prod)'; then
            BASE_ENV=$(printf '%s' "$REPO_PART" | sed -nE 's@.*frontend-((dev|test|train|prod)).*@\1@p')
          else
            # Fallback: default to 'dev'
            BASE_ENV=dev
          fi
          RUN_TEST=false
          RUN_TRAIN=false
          RUN_PROD=false
          case "$BASE_ENV" in
            dev)
              RUN_TEST=true; RUN_TRAIN=true; RUN_PROD=true;;
            test)
              RUN_TRAIN=true; RUN_PROD=true;;
            train)
              RUN_PROD=true;;
            prod)
              :;;
          esac
          echo "baseEnv=$BASE_ENV" >> "$GITHUB_OUTPUT"
          echo "run_test=$RUN_TEST" >> "$GITHUB_OUTPUT"
          echo "run_train=$RUN_TRAIN" >> "$GITHUB_OUTPUT"
          echo "run_prod=$RUN_PROD" >> "$GITHUB_OUTPUT"

  prepare-and-notify-test:
    name: Prepare & Notify (test)
    if: ${{ needs.plan.outputs.run_test == 'true' }}
    needs: plan
    runs-on: ubuntu-latest
    environment: preflight
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: test
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
      SRC_REPO: ${{ needs.plan.outputs.srcRepo }}
      FRONTEND_REPO_READ_TOKEN: ${{ secrets.FRONTEND_REPO_READ_TOKEN }}
      MAIL_SERVER: ${{ secrets.MAIL_SERVER }}
      MAIL_PORT: ${{ secrets.MAIL_PORT }}
      MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
      MAIL_TO: ${{ secrets.MAIL_TO }}
      MAIL_FROM: ${{ secrets.MAIL_FROM }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          allow-no-subscriptions: true

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV='${{ env.TARGET_ENV }}'
          # Try environment-specific variables first (e.g., AZURE_ACR_NAME_TEST, AZURE_RESOURCE_GROUP_TEST)
          # Fall back to generic variables, then conventional names
          ACR_NAME=""
          RG=""
          case "${TARGET_ENV^^}" in
            DEV)
              ACR_NAME='${{ vars.AZURE_ACR_NAME_DEV || vars.AZURE_ACR_NAME || '' }}'
              RG='${{ vars.AZURE_RESOURCE_GROUP_DEV || vars.AZURE_RESOURCE_GROUP || '' }}'
              ;;
            TEST)
              ACR_NAME='${{ vars.AZURE_ACR_NAME_TEST || vars.AZURE_ACR_NAME || '' }}'
              RG='${{ vars.AZURE_RESOURCE_GROUP_TEST || vars.AZURE_RESOURCE_GROUP || '' }}'
              ;;
            TRAIN)
              ACR_NAME='${{ vars.AZURE_ACR_NAME_TRAIN || vars.AZURE_ACR_NAME || '' }}'
              RG='${{ vars.AZURE_RESOURCE_GROUP_TRAIN || vars.AZURE_RESOURCE_GROUP || '' }}'
              ;;
            PROD)
              ACR_NAME='${{ vars.AZURE_ACR_NAME_PROD || vars.AZURE_ACR_NAME || '' }}'
              RG='${{ vars.AZURE_RESOURCE_GROUP_PROD || vars.AZURE_RESOURCE_GROUP || '' }}'
              ;;
          esac
          if [ -z "$RG" ]; then RG="rg-raptor-${TARGET_ENV}"; fi
          SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          LOC=$(az group show -n "$RG" ${SUB:+--subscription "$SUB"} --query location -o tsv 2>/dev/null || true)
          [ -n "$ACR_NAME" ] && echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          [ -n "$LOC" ] && echo "loc=$LOC" >> $GITHUB_OUTPUT
          [ -n "$SUB" ] && echo "sub=$SUB" >> $GITHUB_OUTPUT
          echo "srcRepo=${{ env.SRC_REPO }}" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Capture current deployed image (before promotion)
        id: current
        shell: bash
        run: |
          set -euo pipefail
          ENV='${{ steps.prep.outputs.env }}'
          RG='${{ steps.prep.outputs.rg }}'
          SUB='${{ steps.prep.outputs.sub }}'
          if [ -z "$SUB" ]; then SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'; fi
          if [ -z "$SUB" ]; then
            SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          az extension add -n containerapp -y >/dev/null 2>&1 || true
          CURR_IMG=$(az containerapp show -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} --query "properties.template.containers[0].image" -o tsv 2>/dev/null || true)
          CURR_DIGEST="${CURR_IMG#*@}"
          if [ "$CURR_IMG" = "$CURR_DIGEST" ]; then CURR_DIGEST=""; fi
          echo "image=$CURR_IMG" >> $GITHUB_OUTPUT
          echo "digest=$CURR_DIGEST" >> $GITHUB_OUTPUT

      - name: Make utility scripts executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x scripts/*.sh || true

      - name: Generate release notes (shared)
        id: relnotes
        shell: bash
        env:
          SRC_IMAGE: ${{ env.SRC_IMAGE }}
          SRC_REPO: ${{ env.SRC_REPO }}
          TARGET_ENV: ${{ steps.prep.outputs.env }}
          RG: ${{ steps.prep.outputs.rg }}
          SUB: ${{ steps.prep.outputs.sub || secrets.AZURE_SUBSCRIPTION_ID }}
          TGT_ACR: ${{ steps.prep.outputs.acr }}
          PREV_IMAGE: ${{ steps.current.outputs.image }}
          PREV_DIGEST: ${{ steps.current.outputs.digest }}
          COMMITS_TABLE_LIMIT: ${{ vars.COMMITS_TABLE_LIMIT || 50 }}
          FRONTEND_REPO_READ_TOKEN: ${{ env.FRONTEND_REPO_READ_TOKEN }}
          BUILD_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -euo pipefail
          bash scripts/relnotes.sh

      - name: Append release notes to summary
        shell: bash
        run: |
          set -euo pipefail
          cat release-notes.md >> "$GITHUB_STEP_SUMMARY"
          printf '\n<!-- Rendered HTML changelog -->\n' >> "$GITHUB_STEP_SUMMARY"
          cat release-notes.html >> "$GITHUB_STEP_SUMMARY"

      - name: ACR label access diagnostics (preflight)
        if: always()
        shell: bash
        env:
          SRC_IMAGE: ${{ env.SRC_IMAGE }}
        run: |
          set -euo pipefail
          echo "=== ACR label access diagnostics ==="
          TGT_ENV='${{ steps.prep.outputs.env }}'
          TGT_ACR='${{ steps.prep.outputs.acr || '' }}'
          PREV_IMAGE='${{ steps.current.outputs.image || '' }}'
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          if [ -n "$TGT_ACR" ]; then
            echo "Target ACR: $TGT_ACR"
            tok=$(az acr login -n "$TGT_ACR" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            if [ -n "$tok" ]; then echo " - Token: OK"; else echo " - Token: MISSING (no data-plane access)"; fi
          else
            echo "Target ACR: (not set)"
          fi
          echo "Source ACR: $SRC_REG_NAME"
          stok=$(az acr login -n "$SRC_REG_NAME" --expose-token -o tsv --query accessToken 2>/dev/null || true)
          if [ -n "$stok" ]; then echo " - Token: OK"; else echo " - Token: MISSING (no data-plane access)"; fi
          if [ -n "$PREV_IMAGE" ]; then
            PREV_DOMAIN="${PREV_IMAGE%%/*}"
            PREV_REG_NAME=$(echo "$PREV_DOMAIN" | sed 's/\.azurecr\.io$//')
            echo "Previous image ACR: $PREV_REG_NAME"
            ptok=$(az acr login -n "$PREV_REG_NAME" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            if [ -n "$ptok" ]; then echo " - Token: OK"; else echo " - Token: MISSING (no data-plane access)"; fi
          fi
          echo "===================================="

      - name: Check email prerequisites
        shell: bash
        run: |
          set -euo pipefail
          missing=()
          for v in MAIL_SERVER MAIL_USERNAME MAIL_PASSWORD MAIL_TO; do
            if [ -z "${!v:-}" ]; then missing+=("$v"); fi
          done
          if [ ${#missing[@]} -gt 0 ]; then
            echo "Email will be skipped. Missing variables: ${missing[*]}"
          else
            echo "Email prerequisites present."
          fi

      - name: Check environment approvals (required reviewers)
        id: gate
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          ENV='${{ steps.prep.outputs.env }}'
          REPO='${{ github.repository }}'
          URL="https://api.github.com/repos/${REPO}/environments/${ENV}"
          JSON=$(curl -fsS -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" "$URL" || true)
          COUNT=$(printf '%s' "$JSON" | jq -r '[.protection_rules[]? | select(.type=="required_reviewers") | (.reviewers // []) | length] | add // 0')
          NEED="false"; if [ "${COUNT:-0}" -gt 0 ]; then NEED="true"; fi
          echo "needsApproval=$NEED" >> $GITHUB_OUTPUT

      - name: Compose email (shared)
        id: email_compose
        shell: bash
        env:
          TARGET_ENV: ${{ steps.prep.outputs.env }}
          SRC_IMAGE: ${{ env.SRC_IMAGE }}
          NEEDS_APPROVAL: ${{ steps.gate.outputs.needsApproval }}
          RELEASE_HTML: release-notes.html
          BUILD_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -euo pipefail
          
          NEEDS_APPROVAL=${NEEDS_APPROVAL:-false}
          SUBJECT_PREFIX="[Deployment Notice]"
          INTRO="A deployment to the '<strong>${TARGET_ENV}</strong>' environment is ready."
          
          if [ "$NEEDS_APPROVAL" = "true" ]; then
            SUBJECT_PREFIX="[Approval Needed]"
            INTRO="A deployment to the '<strong>${TARGET_ENV}</strong>' environment is pending approval."
          fi
          
          SUBJECT="$SUBJECT_PREFIX Promote frontend to ${TARGET_ENV}"
          EMAIL_HTML="email.html"
          
          {
            printf "<p>%s</p>\n" "$INTRO"
            printf "<p><strong>Image:</strong> %s<br>\n<strong>Target:</strong> Azure Container Apps (%s)</p>\n" "$SRC_IMAGE" "$TARGET_ENV"
            if [ "$NEEDS_APPROVAL" = "true" ]; then
              printf "<p><a href=\"%s\">Build details</a> • <a href=\"%s\">Review &amp; approve</a></p>\n" "$BUILD_URL" "$BUILD_URL"
            else
              printf "<p><a href=\"%s\">Build details</a></p>\n" "$BUILD_URL"
            fi
            cat "$RELEASE_HTML" || true
          } > "$EMAIL_HTML"
          
          {
            echo "subject<<EOF"
            echo "$SUBJECT"
            echo "EOF"
            echo "html<<EOF"
            cat "$EMAIL_HTML"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Email approver/notify (optional)
        if: ${{ env.MAIL_SERVER && env.MAIL_USERNAME && env.MAIL_PASSWORD && env.MAIL_TO }}
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ env.MAIL_SERVER }}
          server_port: ${{ env.MAIL_PORT || 587 }}
          username: ${{ env.MAIL_USERNAME }}
          password: ${{ env.MAIL_PASSWORD }}
          subject: "${{ steps.email_compose.outputs.subject }}"
          to: ${{ env.MAIL_TO }}
          from: "${{ env.MAIL_FROM || format('github-actions@{0}', github.repository_owner) }}"
          html_body: "${{ steps.email_compose.outputs.html }}"

  promote-to-test:
    name: Promote to test
    if: ${{ needs.plan.outputs.run_test == 'true' }}
    runs-on: ubuntu-latest
    needs: [plan, prepare-and-notify-test]
    environment: test
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: test
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV=${TARGET_ENV}
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP }}'
          if [ -z "$ACR_NAME" ] || [ -z "$RG" ]; then
            echo "Missing AZURE_ACR_NAME or AZURE_RESOURCE_GROUP for '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          LOC=$(az group show -n "$RG" --query location -o tsv 2>/dev/null || true)
          if [ -z "$LOC" ]; then
            echo "Could not resolve location for resource group '$RG' in '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          echo "loc=$LOC" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Ensure target ACR exists
        shell: bash
        run: |
          set -euo pipefail
          ACR='${{ steps.prep.outputs.acr }}'
          # Prefer override RG when provided for cross-RG ACR
          ACR_RG='${{ vars.AZURE_ACR_RESOURCE_GROUP }}'
          if [ -z "$ACR_RG" ]; then ACR_RG='${{ steps.prep.outputs.rg }}'; fi
          echo "Ensuring ACR '$ACR' exists in resource group '$ACR_RG'"
          az acr show -n "$ACR" -g "$ACR_RG" >/dev/null 2>&1 || az acr create -n "$ACR" -g "$ACR_RG" --sku Standard >/dev/null

      - name: Import manifest into target ACR repo
        id: import
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          ACR='${{ steps.prep.outputs.acr }}'
          TARGET_REPO="raptor/frontend-${{ steps.prep.outputs.env }}"
          TAG="promoted-${GITHUB_RUN_ID}"
          echo "Importing $SRC_IMAGE -> $ACR/$TARGET_REPO:$TAG"
          az acr import -n "$ACR" --source "$SRC_IMAGE" --image "$TARGET_REPO:$TAG"
          DIGEST="${SRC_IMAGE#*@}"
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Prepare azd env
        shell: bash
        run: |
          set -euo pipefail
          azd config set alpha.deployment.stacks on
          azd env new ${{ steps.prep.outputs.env }} --no-prompt || true
          azd env set AZURE_ENV_NAME "${{ steps.prep.outputs.env }}"
          azd env set AZURE_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          azd env set AZURE_SUBSCRIPTION_ID "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          azd env set AZURE_ACR_NAME "${{ steps.prep.outputs.acr }}"
          # Pass cross-RG override for ACR when configured
          if [ -n "${{ vars.AZURE_ACR_RESOURCE_GROUP }}" ]; then
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ vars.AZURE_ACR_RESOURCE_GROUP }}"
          else
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          fi
          azd env set SERVICE_FRONTEND_IMAGE_NAME "${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false

      - name: Fast image-only update (skip provision when possible)
        id: fastpath_test
        shell: bash
        run: |
          set -euo pipefail
          APP_NAME=$(echo "${{ steps.prep.outputs.env }}-rap-fe" | tr '[:upper:]' '[:lower:]')
          IMG="${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          DIGEST_PART="${IMG#*@}"
          if [ "$IMG" = "$DIGEST_PART" ]; then
            echo "Image is not digest-form; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          if ! az containerapp show -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" >/dev/null 2>&1; then
            echo "Container App does not exist; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Performing direct image update to: $IMG"
          az containerapp update -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" --image "$IMG"
          echo "didFastPath=true" >> $GITHUB_OUTPUT

      - name: Make preprovision hooks executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x ./scripts/ensure-acr.sh

      - name: Deploy to ${{ steps.prep.outputs.env }}
        if: steps.fastpath_test.outputs.didFastPath != 'true'
        run: azd up --no-prompt --environment "${{ steps.prep.outputs.env }}"

      - name: Expose deployment endpoints
        id: expose_endpoints
        shell: bash
        run: |
          set -euo pipefail
          RAW=$(azd env get-value frontendFqdn 2>/dev/null || true)
          FQDN=$(printf '%s' "$RAW" | tr -d '\r' | head -n1)
          if printf '%s' "$FQDN" | grep -qi '^error:'; then FQDN=""; fi
          if [ -z "$FQDN" ]; then
            ENV="${{ steps.prep.outputs.env }}"
            RG="${{ steps.prep.outputs.rg }}"
            APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            az extension add -n containerapp -y >/dev/null 2>&1 || true
            CA_FQDN=$(az containerapp show -n "$APP_NAME" -g "$RG" --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || true)
            if [ "$CA_FQDN" = "null" ]; then CA_FQDN=""; fi
            FQDN=$(printf '%s' "$CA_FQDN" | tr -d '\r' | head -n1)
            if [ -n "$FQDN" ]; then
              azd env set frontendFqdn "$FQDN" >/dev/null || true
            fi
          fi
          if [ -n "$FQDN" ]; then
            echo "frontendFqdn=$FQDN" >> $GITHUB_OUTPUT
            echo "Frontend URL: https://$FQDN"
          else
            echo "Frontend URL not available"
          fi
          {
            echo "### Deployment endpoints"
            echo ""
            if [ -n "$FQDN" ]; then
              echo "- Frontend: https://$FQDN"
            else
              echo "- Frontend: (not available)"
            fi
          } >> $GITHUB_STEP_SUMMARY

      - name: Persist deployment metadata to tags
        shell: bash
        run: |
          set -euo pipefail
          ENV="${{ steps.prep.outputs.env }}"
          RG="${{ steps.prep.outputs.rg }}"
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if [ -z "$SUB" ]; then SUB=$(az account show --query id -o tsv 2>/dev/null || true); fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          NEW_DIGEST='${{ steps.import.outputs.digest }}'
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          SRC_REPO="${SRC_PATH%@*}"
          get_commit_from_labels() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then echo ""; return 0; fi
            local tok
            tok=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            [ -z "$tok" ] && { echo ""; return 0; }
            local base="https://${reg}.azurecr.io/v2/${repo}"
            local mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json' "$base/manifests/$dig" 2>/dev/null || true)
            [ -z "$mf" ] && { echo ""; return 0; }
            local media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')
            if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
              local child=$(printf '%s' "$mf" | jq -r '.manifests[0].digest // empty')
              [ -n "$child" ] && mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$base/manifests/$child" 2>/dev/null || true)
            fi
            local cfg=$(printf '%s' "$mf" | jq -r '.config.digest // empty')
            [ -z "$cfg" ] && { echo ""; return 0; }
            local cfgJson=$(curl -fsSL -H "Authorization: Bearer $tok" "$base/blobs/$cfg" 2>/dev/null || true)
            [ -z "$cfgJson" ] && { echo ""; return 0; }
            local rev=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
            printf '%s' "$rev"
          }
          NEW_SHA=$(get_commit_from_labels "$SRC_REG_NAME" "$SRC_REPO" "$NEW_DIGEST")
          echo "Updating tags on Container App '$APP_NAME' in RG '$RG'"
          if [ -z "$NEW_DIGEST" ]; then echo "No digest to persist; skipping tag update."; exit 0; fi
          TAG_ARGS=("raptor.lastDigest=${NEW_DIGEST}")
          if [ -n "$NEW_SHA" ]; then TAG_ARGS+=("raptor.lastCommit=${NEW_SHA}"); fi
          az resource tag -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} \
            --resource-type "Microsoft.App/containerApps" \
            --is-incremental \
            --tags "${TAG_ARGS[@]}" >/dev/null

  prepare-and-notify-train:
    name: Prepare & Notify (train)
    if: ${{ needs.plan.outputs.run_train == 'true' }}
    needs: [plan, after-test]
    runs-on: ubuntu-latest
    environment: preflight
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: train
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
      SRC_REPO: ${{ needs.plan.outputs.srcRepo }}
      FRONTEND_REPO_READ_TOKEN: ${{ secrets.FRONTEND_REPO_READ_TOKEN }}
      MAIL_SERVER: ${{ secrets.MAIL_SERVER }}
      MAIL_PORT: ${{ secrets.MAIL_PORT }}
      MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
      MAIL_TO: ${{ secrets.MAIL_TO }}
      MAIL_FROM: ${{ secrets.MAIL_FROM }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          allow-no-subscriptions: true

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV='${{ env.TARGET_ENV }}'
          # Try environment-specific variable first (e.g., AZURE_RESOURCE_GROUP_TRAIN)
          # Fall back to generic AZURE_RESOURCE_GROUP, then conventional name
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG=""
          case "${TARGET_ENV^^}" in
            DEV)   RG='${{ vars.AZURE_RESOURCE_GROUP_DEV || vars.AZURE_RESOURCE_GROUP || '' }}' ;;
            TEST)  RG='${{ vars.AZURE_RESOURCE_GROUP_TEST || vars.AZURE_RESOURCE_GROUP || '' }}' ;;
            TRAIN) RG='${{ vars.AZURE_RESOURCE_GROUP_TRAIN || vars.AZURE_RESOURCE_GROUP || '' }}' ;;
            PROD)  RG='${{ vars.AZURE_RESOURCE_GROUP_PROD || vars.AZURE_RESOURCE_GROUP || '' }}' ;;
          esac
          if [ -z "$RG" ]; then RG="rg-raptor-${TARGET_ENV}"; fi
          SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          LOC=$(az group show -n "$RG" ${SUB:+--subscription "$SUB"} --query location -o tsv 2>/dev/null || true)
          [ -n "$ACR_NAME" ] && echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          [ -n "$LOC" ] && echo "loc=$LOC" >> $GITHUB_OUTPUT
          [ -n "$SUB" ] && echo "sub=$SUB" >> $GITHUB_OUTPUT
          echo "srcRepo=${{ env.SRC_REPO }}" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Capture current deployed image (before promotion)
        id: current
        shell: bash
        run: |
          set -euo pipefail
          ENV='${{ steps.prep.outputs.env }}'
          RG='${{ steps.prep.outputs.rg }}'
          SUB='${{ steps.prep.outputs.sub }}'
          if [ -z "$SUB" ]; then SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'; fi
          if [ -z "$SUB" ]; then
            SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          az extension add -n containerapp -y >/dev/null 2>&1 || true
          CURR_IMG=$(az containerapp show -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} --query "properties.template.containers[0].image" -o tsv 2>/dev/null || true)
          CURR_DIGEST="${CURR_IMG#*@}"
          if [ "$CURR_IMG" = "$CURR_DIGEST" ]; then CURR_DIGEST=""; fi
          echo "image=$CURR_IMG" >> $GITHUB_OUTPUT
          echo "digest=$CURR_DIGEST" >> $GITHUB_OUTPUT

      - name: Make utility scripts executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x scripts/*.sh || true

      - name: Generate release notes (shared)
        id: relnotes
        shell: bash
        env:
          SRC_IMAGE: ${{ env.SRC_IMAGE }}
          SRC_REPO: ${{ env.SRC_REPO }}
          TARGET_ENV: ${{ steps.prep.outputs.env }}
          RG: ${{ steps.prep.outputs.rg }}
          SUB: ${{ steps.prep.outputs.sub || secrets.AZURE_SUBSCRIPTION_ID }}
          TGT_ACR: ${{ steps.prep.outputs.acr }}
          PREV_IMAGE: ${{ steps.current.outputs.image }}
          PREV_DIGEST: ${{ steps.current.outputs.digest }}
          COMMITS_TABLE_LIMIT: ${{ vars.COMMITS_TABLE_LIMIT || 50 }}
          FRONTEND_REPO_READ_TOKEN: ${{ env.FRONTEND_REPO_READ_TOKEN }}
          BUILD_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -euo pipefail
          bash scripts/relnotes.sh

      - name: Append release notes to summary
        shell: bash
        run: |
          set -euo pipefail
          cat release-notes.md >> "$GITHUB_STEP_SUMMARY"
          printf '\n<!-- Rendered HTML changelog -->\n' >> "$GITHUB_STEP_SUMMARY"
          cat release-notes.html >> "$GITHUB_STEP_SUMMARY"

      - name: Check environment approvals (required reviewers)
        id: gate
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          ENV='${{ steps.prep.outputs.env }}'
          REPO='${{ github.repository }}'
          URL="https://api.github.com/repos/${REPO}/environments/${ENV}"
          JSON=$(curl -fsS -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" "$URL" || true)
          COUNT=$(printf '%s' "$JSON" | jq -r '[.protection_rules[]? | select(.type=="required_reviewers") | (.reviewers // []) | length] | add // 0')
          NEED="false"; if [ "${COUNT:-0}" -gt 0 ]; then NEED="true"; fi
          echo "needsApproval=$NEED" >> $GITHUB_OUTPUT

      - name: Compose email (shared)
        id: email_compose
        shell: bash
        env:
          TARGET_ENV: ${{ steps.prep.outputs.env }}
          SRC_IMAGE: ${{ env.SRC_IMAGE }}
          NEEDS_APPROVAL: ${{ steps.gate.outputs.needsApproval }}
          RELEASE_HTML: release-notes.html
          BUILD_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -euo pipefail
          
          NEEDS_APPROVAL=${NEEDS_APPROVAL:-false}
          SUBJECT_PREFIX="[Deployment Notice]"
          INTRO="A deployment to the '<strong>${TARGET_ENV}</strong>' environment is ready."
          
          if [ "$NEEDS_APPROVAL" = "true" ]; then
            SUBJECT_PREFIX="[Approval Needed]"
            INTRO="A deployment to the '<strong>${TARGET_ENV}</strong>' environment is pending approval."
          fi
          
          SUBJECT="$SUBJECT_PREFIX Promote frontend to ${TARGET_ENV}"
          EMAIL_HTML="email.html"
          
          {
            printf "<p>%s</p>\n" "$INTRO"
            printf "<p><strong>Image:</strong> %s<br>\n<strong>Target:</strong> Azure Container Apps (%s)</p>\n" "$SRC_IMAGE" "$TARGET_ENV"
            if [ "$NEEDS_APPROVAL" = "true" ]; then
              printf "<p><a href=\"%s\">Build details</a> • <a href=\"%s\">Review &amp; approve</a></p>\n" "$BUILD_URL" "$BUILD_URL"
            else
              printf "<p><a href=\"%s\">Build details</a></p>\n" "$BUILD_URL"
            fi
            cat "$RELEASE_HTML" || true
          } > "$EMAIL_HTML"
          
          {
            echo "subject<<EOF"
            echo "$SUBJECT"
            echo "EOF"
            echo "html<<EOF"
            cat "$EMAIL_HTML"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Email approver/notify (optional)
        if: ${{ env.MAIL_SERVER && env.MAIL_USERNAME && env.MAIL_PASSWORD && env.MAIL_TO }}
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ env.MAIL_SERVER }}
          server_port: ${{ env.MAIL_PORT || 587 }}
          username: ${{ env.MAIL_USERNAME }}
          password: ${{ env.MAIL_PASSWORD }}
          subject: "${{ steps.email_compose.outputs.subject }}"
          to: ${{ env.MAIL_TO }}
          from: "${{ env.MAIL_FROM || format('github-actions@{0}', github.repository_owner) }}"
          html_body: "${{ steps.email_compose.outputs.html }}"

  after-test:
    name: Barrier after test
    if: ${{ always() }}
    needs: [plan, promote-to-test]
    runs-on: ubuntu-latest
    steps:
      - run: echo "Proceeding to train stage"

  promote-to-train:
    name: Promote to train
    if: ${{ needs.plan.outputs.run_train == 'true' }}
    runs-on: ubuntu-latest
    needs: [plan, prepare-and-notify-train]
    environment: train
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: train
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV=${TARGET_ENV}
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP }}'
          if [ -z "$ACR_NAME" ] || [ -z "$RG" ]; then
            echo "Missing AZURE_ACR_NAME or AZURE_RESOURCE_GROUP for '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          LOC=$(az group show -n "$RG" --query location -o tsv 2>/dev/null || true)
          if [ -z "$LOC" ]; then
            echo "Could not resolve location for resource group '$RG' in '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          echo "loc=$LOC" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Ensure target ACR exists
        shell: bash
        run: |
          set -euo pipefail
          ACR='${{ steps.prep.outputs.acr }}'
          ACR_RG='${{ vars.AZURE_ACR_RESOURCE_GROUP }}'
          if [ -z "$ACR_RG" ]; then ACR_RG='${{ steps.prep.outputs.rg }}'; fi
          echo "Ensuring ACR '$ACR' exists in resource group '$ACR_RG'"
          az acr show -n "$ACR" -g "$ACR_RG" >/dev/null 2>&1 || az acr create -n "$ACR" -g "$ACR_RG" --sku Standard >/dev/null

      - name: Import manifest into target ACR repo
        id: import
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          ACR='${{ steps.prep.outputs.acr }}'
          TARGET_REPO="raptor/frontend-${{ steps.prep.outputs.env }}"
          TAG="promoted-${GITHUB_RUN_ID}"
          echo "Importing $SRC_IMAGE -> $ACR/$TARGET_REPO:$TAG"
          az acr import -n "$ACR" --source "$SRC_IMAGE" --image "$TARGET_REPO:$TAG"
          DIGEST="${SRC_IMAGE#*@}"
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Prepare azd env
        shell: bash
        run: |
          set -euo pipefail
          azd config set alpha.deployment.stacks on
          azd env new ${{ steps.prep.outputs.env }} --no-prompt || true
          azd env set AZURE_ENV_NAME "${{ steps.prep.outputs.env }}"
          azd env set AZURE_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          azd env set AZURE_SUBSCRIPTION_ID "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          azd env set AZURE_ACR_NAME "${{ steps.prep.outputs.acr }}"
          if [ -n "${{ vars.AZURE_ACR_RESOURCE_GROUP }}" ]; then
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ vars.AZURE_ACR_RESOURCE_GROUP }}"
          else
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          fi
          azd env set SERVICE_FRONTEND_IMAGE_NAME "${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false

      - name: Fast image-only update (skip provision when possible)
        id: fastpath_train
        shell: bash
        run: |
          set -euo pipefail
          APP_NAME=$(echo "${{ steps.prep.outputs.env }}-rap-fe" | tr '[:upper:]' '[:lower:]')
          IMG="${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          DIGEST_PART="${IMG#*@}"
          if [ "$IMG" = "$DIGEST_PART" ]; then
            echo "Image is not digest-form; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          if ! az containerapp show -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" >/dev/null 2>&1; then
            echo "Container App does not exist; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Performing direct image update to: $IMG"
          az containerapp update -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" --image "$IMG"
          echo "didFastPath=true" >> $GITHUB_OUTPUT

      - name: Make preprovision hooks executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x ./scripts/ensure-acr.sh

      - name: Deploy to ${{ steps.prep.outputs.env }}
        if: steps.fastpath_train.outputs.didFastPath != 'true'
        run: azd up --no-prompt --environment "${{ steps.prep.outputs.env }}"

      - name: Expose deployment endpoints
        id: expose_endpoints
        shell: bash
        run: |
          set -euo pipefail
          RAW=$(azd env get-value frontendFqdn 2>/dev/null || true)
          FQDN=$(printf '%s' "$RAW" | tr -d '\r' | head -n1)
          if printf '%s' "$FQDN" | grep -qi '^error:'; then FQDN=""; fi
          if [ -z "$FQDN" ]; then
            ENV="${{ steps.prep.outputs.env }}"
            RG="${{ steps.prep.outputs.rg }}"
            APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            az extension add -n containerapp -y >/dev/null 2>&1 || true
            CA_FQDN=$(az containerapp show -n "$APP_NAME" -g "$RG" --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || true)
            if [ "$CA_FQDN" = "null" ]; then CA_FQDN=""; fi
            FQDN=$(printf '%s' "$CA_FQDN" | tr -d '\r' | head -n1)
            if [ -n "$FQDN" ]; then
              azd env set frontendFqdn "$FQDN" >/dev/null || true
            fi
          fi
          if [ -n "$FQDN" ]; then
            echo "frontendFqdn=$FQDN" >> $GITHUB_OUTPUT
            echo "Frontend URL: https://$FQDN"
          else
            echo "Frontend URL not available"
          fi
          {
            echo "### Deployment endpoints"
            echo ""
            if [ -n "$FQDN" ]; then
              echo "- Frontend: https://$FQDN"
            else
              echo "- Frontend: (not available)"
            fi
          } >> $GITHUB_STEP_SUMMARY

      - name: Persist deployment metadata to tags
        shell: bash
        run: |
          set -euo pipefail
          ENV="${{ steps.prep.outputs.env }}"
          RG="${{ steps.prep.outputs.rg }}"
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if [ -z "$SUB" ]; then SUB=$(az account show --query id -o tsv 2>/dev/null || true); fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          NEW_DIGEST='${{ steps.import.outputs.digest }}'
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          SRC_REPO="${SRC_PATH%@*}"
          get_commit_from_labels() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then echo ""; return 0; fi
            local tok
            tok=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            [ -z "$tok" ] && { echo ""; return 0; }
            local base="https://${reg}.azurecr.io/v2/${repo}"
            local mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json' "$base/manifests/$dig" 2>/dev/null || true)
            [ -z "$mf" ] && { echo ""; return 0; }
            local media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')
            if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
              local child=$(printf '%s' "$mf" | jq -r '.manifests[0].digest // empty')
              [ -n "$child" ] && mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$base/manifests/$child" 2>/dev/null || true)
            fi
            local cfg=$(printf '%s' "$mf" | jq -r '.config.digest // empty')
            [ -z "$cfg" ] && { echo ""; return 0; }
            local cfgJson=$(curl -fsSL -H "Authorization: Bearer $tok" "$base/blobs/$cfg" 2>/dev/null || true)
            [ -z "$cfgJson" ] && { echo ""; return 0; }
            local rev=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
            printf '%s' "$rev"
          }
          NEW_SHA=$(get_commit_from_labels "$SRC_REG_NAME" "$SRC_REPO" "$NEW_DIGEST")
          echo "Updating tags on Container App '$APP_NAME' in RG '$RG'"
          if [ -z "$NEW_DIGEST" ]; then echo "No digest to persist; skipping tag update."; exit 0; fi
          TAG_ARGS=("raptor.lastDigest=${NEW_DIGEST}")
          if [ -n "$NEW_SHA" ]; then TAG_ARGS+=("raptor.lastCommit=${NEW_SHA}"); fi
          az resource tag -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} \
            --resource-type "Microsoft.App/containerApps" \
            --is-incremental \
            --tags "${TAG_ARGS[@]}" >/dev/null

  after-train:
    name: Barrier after train
    if: ${{ always() }}
    needs: [plan, promote-to-train]
    runs-on: ubuntu-latest
    steps:
      - run: echo "Proceeding to prod stage"

  prepare-and-notify-prod:
    name: Prepare & Notify (prod)
    if: ${{ needs.plan.outputs.run_prod == 'true' }}
    needs: [plan, after-train]
    runs-on: ubuntu-latest
    environment: preflight
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: prod
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
      SRC_REPO: ${{ needs.plan.outputs.srcRepo }}
      FRONTEND_REPO_READ_TOKEN: ${{ secrets.FRONTEND_REPO_READ_TOKEN }}
      MAIL_SERVER: ${{ secrets.MAIL_SERVER }}
      MAIL_PORT: ${{ secrets.MAIL_PORT }}
      MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
      MAIL_TO: ${{ secrets.MAIL_TO }}
      MAIL_FROM: ${{ secrets.MAIL_FROM }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          allow-no-subscriptions: true

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV='${{ env.TARGET_ENV }}'
          # Try environment-specific variable first (e.g., AZURE_RESOURCE_GROUP_PROD)
          # Fall back to generic AZURE_RESOURCE_GROUP, then conventional name
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG=""
          case "${TARGET_ENV^^}" in
            DEV)   RG='${{ vars.AZURE_RESOURCE_GROUP_DEV || vars.AZURE_RESOURCE_GROUP || '' }}' ;;
            TEST)  RG='${{ vars.AZURE_RESOURCE_GROUP_TEST || vars.AZURE_RESOURCE_GROUP || '' }}' ;;
            TRAIN) RG='${{ vars.AZURE_RESOURCE_GROUP_TRAIN || vars.AZURE_RESOURCE_GROUP || '' }}' ;;
            PROD)  RG='${{ vars.AZURE_RESOURCE_GROUP_PROD || vars.AZURE_RESOURCE_GROUP || '' }}' ;;
          esac
          if [ -z "$RG" ]; then RG="rg-raptor-${TARGET_ENV}"; fi
          SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          LOC=$(az group show -n "$RG" ${SUB:+--subscription "$SUB"} --query location -o tsv 2>/dev/null || true)
          [ -n "$ACR_NAME" ] && echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          [ -n "$LOC" ] && echo "loc=$LOC" >> $GITHUB_OUTPUT
          [ -n "$SUB" ] && echo "sub=$SUB" >> $GITHUB_OUTPUT
          echo "srcRepo=${{ env.SRC_REPO }}" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Capture current deployed image (before promotion)
        id: current
        shell: bash
        run: |
          set -euo pipefail
          ENV='${{ steps.prep.outputs.env }}'
          RG='${{ steps.prep.outputs.rg }}'
          SUB='${{ steps.prep.outputs.sub }}'
          if [ -z "$SUB" ]; then SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'; fi
          if [ -z "$SUB" ]; then
            SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          az extension add -n containerapp -y >/dev/null 2>&1 || true
          CURR_IMG=$(az containerapp show -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} --query "properties.template.containers[0].image" -o tsv 2>/dev/null || true)
          CURR_DIGEST="${CURR_IMG#*@}"
          if [ "$CURR_IMG" = "$CURR_DIGEST" ]; then CURR_DIGEST=""; fi
          echo "image=$CURR_IMG" >> $GITHUB_OUTPUT
          echo "digest=$CURR_DIGEST" >> $GITHUB_OUTPUT

      - name: Make utility scripts executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x scripts/*.sh || true

      - name: Generate release notes (shared)
        id: relnotes
        shell: bash
        env:
          SRC_IMAGE: ${{ env.SRC_IMAGE }}
          SRC_REPO: ${{ env.SRC_REPO }}
          TARGET_ENV: ${{ steps.prep.outputs.env }}
          RG: ${{ steps.prep.outputs.rg }}
          SUB: ${{ steps.prep.outputs.sub || secrets.AZURE_SUBSCRIPTION_ID }}
          TGT_ACR: ${{ steps.prep.outputs.acr }}
          PREV_IMAGE: ${{ steps.current.outputs.image }}
          PREV_DIGEST: ${{ steps.current.outputs.digest }}
          COMMITS_TABLE_LIMIT: ${{ vars.COMMITS_TABLE_LIMIT || 50 }}
          FRONTEND_REPO_READ_TOKEN: ${{ env.FRONTEND_REPO_READ_TOKEN }}
          BUILD_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -euo pipefail
          bash scripts/relnotes.sh

      - name: Append release notes to summary
        shell: bash
        run: |
          set -euo pipefail
          cat release-notes.md >> "$GITHUB_STEP_SUMMARY"
          printf '\n<!-- Rendered HTML changelog -->\n' >> "$GITHUB_STEP_SUMMARY"
          cat release-notes.html >> "$GITHUB_STEP_SUMMARY"

      - name: Check environment approvals (required reviewers)
        id: gate
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          ENV='${{ steps.prep.outputs.env }}'
          REPO='${{ github.repository }}'
          URL="https://api.github.com/repos/${REPO}/environments/${ENV}"
          JSON=$(curl -fsS -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" "$URL" || true)
          COUNT=$(printf '%s' "$JSON" | jq -r '[.protection_rules[]? | select(.type=="required_reviewers") | (.reviewers // []) | length] | add // 0')
          NEED="false"; if [ "${COUNT:-0}" -gt 0 ]; then NEED="true"; fi
          echo "needsApproval=$NEED" >> $GITHUB_OUTPUT

      - name: Compose email (shared)
        id: email_compose
        shell: bash
        env:
          TARGET_ENV: ${{ steps.prep.outputs.env }}
          SRC_IMAGE: ${{ env.SRC_IMAGE }}
          NEEDS_APPROVAL: ${{ steps.gate.outputs.needsApproval }}
          RELEASE_HTML: release-notes.html
          BUILD_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -euo pipefail
          
          NEEDS_APPROVAL=${NEEDS_APPROVAL:-false}
          SUBJECT_PREFIX="[Deployment Notice]"
          INTRO="A deployment to the '<strong>${TARGET_ENV}</strong>' environment is ready."
          
          if [ "$NEEDS_APPROVAL" = "true" ]; then
            SUBJECT_PREFIX="[Approval Needed]"
            INTRO="A deployment to the '<strong>${TARGET_ENV}</strong>' environment is pending approval."
          fi
          
          SUBJECT="$SUBJECT_PREFIX Promote frontend to ${TARGET_ENV}"
          EMAIL_HTML="email.html"
          
          {
            printf "<p>%s</p>\n" "$INTRO"
            printf "<p><strong>Image:</strong> %s<br>\n<strong>Target:</strong> Azure Container Apps (%s)</p>\n" "$SRC_IMAGE" "$TARGET_ENV"
            if [ "$NEEDS_APPROVAL" = "true" ]; then
              printf "<p><a href=\"%s\">Build details</a> • <a href=\"%s\">Review &amp; approve</a></p>\n" "$BUILD_URL" "$BUILD_URL"
            else
              printf "<p><a href=\"%s\">Build details</a></p>\n" "$BUILD_URL"
            fi
            cat "$RELEASE_HTML" || true
          } > "$EMAIL_HTML"
          
          {
            echo "subject<<EOF"
            echo "$SUBJECT"
            echo "EOF"
            echo "html<<EOF"
            cat "$EMAIL_HTML"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Email approver/notify (optional)
        if: ${{ env.MAIL_SERVER && env.MAIL_USERNAME && env.MAIL_PASSWORD && env.MAIL_TO }}
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ env.MAIL_SERVER }}
          server_port: ${{ env.MAIL_PORT || 587 }}
          username: ${{ env.MAIL_USERNAME }}
          password: ${{ env.MAIL_PASSWORD }}
          subject: "${{ steps.email_compose.outputs.subject }}"
          to: ${{ env.MAIL_TO }}
          from: "${{ env.MAIL_FROM || format('github-actions@{0}', github.repository_owner) }}"
          html_body: "${{ steps.email_compose.outputs.html }}"

  promote-to-prod:
    name: Promote to prod
    if: ${{ needs.plan.outputs.run_prod == 'true' }}
    runs-on: ubuntu-latest
    needs: [plan, prepare-and-notify-prod]
    environment: prod
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: prod
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV=${TARGET_ENV}
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP }}'
          if [ -z "$ACR_NAME" ] || [ -z "$RG" ]; then
            echo "Missing AZURE_ACR_NAME or AZURE_RESOURCE_GROUP for '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          LOC=$(az group show -n "$RG" --query location -o tsv 2>/dev/null || true)
          if [ -z "$LOC" ]; then
            echo "Could not resolve location for resource group '$RG' in '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          echo "loc=$LOC" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Ensure target ACR exists
        shell: bash
        run: |
          set -euo pipefail
          ACR='${{ steps.prep.outputs.acr }}'
          ACR_RG='${{ vars.AZURE_ACR_RESOURCE_GROUP }}'
          if [ -z "$ACR_RG" ]; then ACR_RG='${{ steps.prep.outputs.rg }}'; fi
          echo "Ensuring ACR '$ACR' exists in resource group '$ACR_RG'"
          az acr show -n "$ACR" -g "$ACR_RG" >/dev/null 2>&1 || az acr create -n "$ACR" -g "$ACR_RG" --sku Standard >/dev/null

      - name: Import manifest into target ACR repo
        id: import
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          ACR='${{ steps.prep.outputs.acr }}'
          TARGET_REPO="raptor/frontend-${{ steps.prep.outputs.env }}"
          TAG="promoted-${GITHUB_RUN_ID}"
          echo "Importing $SRC_IMAGE -> $ACR/$TARGET_REPO:$TAG"
          az acr import -n "$ACR" --source "$SRC_IMAGE" --image "$TARGET_REPO:$TAG"
          DIGEST="${SRC_IMAGE#*@}"
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Prepare azd env
        shell: bash
        run: |
          set -euo pipefail
          azd config set alpha.deployment.stacks on
          azd env new ${{ steps.prep.outputs.env }} --no-prompt || true
          azd env set AZURE_ENV_NAME "${{ steps.prep.outputs.env }}"
          azd env set AZURE_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          azd env set AZURE_SUBSCRIPTION_ID "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          azd env set AZURE_ACR_NAME "${{ steps.prep.outputs.acr }}"
          if [ -n "${{ vars.AZURE_ACR_RESOURCE_GROUP }}" ]; then
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ vars.AZURE_ACR_RESOURCE_GROUP }}"
          else
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          fi
          azd env set SERVICE_FRONTEND_IMAGE_NAME "${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false

      - name: Fast image-only update (skip provision when possible)
        id: fastpath_prod
        shell: bash
        run: |
          set -euo pipefail
          APP_NAME=$(echo "${{ steps.prep.outputs.env }}-rap-fe" | tr '[:upper:]' '[:lower:]')
          IMG="${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          DIGEST_PART="${IMG#*@}"
          if [ "$IMG" = "$DIGEST_PART" ]; then
            echo "Image is not digest-form; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          if ! az containerapp show -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" >/dev/null 2>&1; then
            echo "Container App does not exist; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Performing direct image update to: $IMG"
          az containerapp update -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" --image "$IMG"
          echo "didFastPath=true" >> $GITHUB_OUTPUT

      - name: Make preprovision hooks executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x ./scripts/ensure-acr.sh

      - name: Deploy to ${{ steps.prep.outputs.env }}
        if: steps.fastpath_prod.outputs.didFastPath != 'true'
        run: azd up --no-prompt --environment "${{ steps.prep.outputs.env }}"

      - name: Expose deployment endpoints
        id: expose_endpoints
        shell: bash
        run: |
          set -euo pipefail
          RAW=$(azd env get-value frontendFqdn 2>/dev/null || true)
          FQDN=$(printf '%s' "$RAW" | tr -d '\r' | head -n1)
          if printf '%s' "$FQDN" | grep -qi '^error:'; then FQDN=""; fi
          if [ -z "$FQDN" ]; then
            ENV="${{ steps.prep.outputs.env }}"
            RG="${{ steps.prep.outputs.rg }}"
            APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            az extension add -n containerapp -y >/dev/null 2>&1 || true
            CA_FQDN=$(az containerapp show -n "$APP_NAME" -g "$RG" --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || true)
            if [ "$CA_FQDN" = "null" ]; then CA_FQDN=""; fi
            FQDN=$(printf '%s' "$CA_FQDN" | tr -d '\r' | head -n1)
            if [ -n "$FQDN" ]; then
              azd env set frontendFqdn "$FQDN" >/dev/null || true
            fi
          fi
          if [ -n "$FQDN" ]; then
            echo "frontendFqdn=$FQDN" >> $GITHUB_OUTPUT
            echo "Frontend URL: https://$FQDN"
          else
            echo "Frontend URL not available"
          fi
          {
            echo "### Deployment endpoints"
            echo ""
            if [ -n "$FQDN" ]; then
              echo "- Frontend: https://$FQDN"
            else
              echo "- Frontend: (not available)"
            fi
          } >> $GITHUB_STEP_SUMMARY

      - name: Persist deployment metadata to tags
        shell: bash
        run: |
          set -euo pipefail
          ENV="${{ steps.prep.outputs.env }}"
          RG="${{ steps.prep.outputs.rg }}"
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if [ -z "$SUB" ]; then SUB=$(az account show --query id -o tsv 2>/dev/null || true); fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          NEW_DIGEST='${{ steps.import.outputs.digest }}'
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          SRC_REPO="${SRC_PATH%@*}"
          get_commit_from_labels() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then echo ""; return 0; fi
            local tok
            tok=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            [ -z "$tok" ] && { echo ""; return 0; }
            local base="https://${reg}.azurecr.io/v2/${repo}"
            local mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json' "$base/manifests/$dig" 2>/dev/null || true)
            [ -z "$mf" ] && { echo ""; return 0; }
            local media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')
            if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
              local child=$(printf '%s' "$mf" | jq -r '.manifests[0].digest // empty')
              [ -n "$child" ] && mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$base/manifests/$child" 2>/dev/null || true)
            fi
            local cfg=$(printf '%s' "$mf" | jq -r '.config.digest // empty')
            [ -z "$cfg" ] && { echo ""; return 0; }
            local cfgJson=$(curl -fsSL -H "Authorization: Bearer $tok" "$base/blobs/$cfg" 2>/dev/null || true)
            [ -z "$cfgJson" ] && { echo ""; return 0; }
            local rev=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
            printf '%s' "$rev"
          }
          NEW_SHA=$(get_commit_from_labels "$SRC_REG_NAME" "$SRC_REPO" "$NEW_DIGEST")
          echo "Updating tags on Container App '$APP_NAME' in RG '$RG'"
          if [ -z "$NEW_DIGEST" ]; then echo "No digest to persist; skipping tag update."; exit 0; fi
          TAG_ARGS=("raptor.lastDigest=${NEW_DIGEST}")
          if [ -n "$NEW_SHA" ]; then TAG_ARGS+=("raptor.lastCommit=${NEW_SHA}"); fi
          az resource tag -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} \
            --resource-type "Microsoft.App/containerApps" \
            --is-incremental \
            --tags "${TAG_ARGS[@]}" >/dev/null

