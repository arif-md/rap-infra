name: Infra - Promote Image to Higher Environments

on:
  workflow_dispatch:
    inputs:
      image:
        description: "Full image with digest (e.g., myacr.azurecr.io/raptor/frontend-dev@sha256:...)"
        required: true
  repository_dispatch:
    types: [ frontend-image-promote ]

jobs:
  plan:
    name: Determine promotion plan
    runs-on: ubuntu-latest
    outputs:
      srcImage: ${{ steps.resolve.outputs.srcImage }}
      srcRepo: ${{ steps.resolve.outputs.srcRepo }}
      baseEnv: ${{ steps.parse.outputs.baseEnv }}
      run_test: ${{ steps.parse.outputs.run_test }}
      run_train: ${{ steps.parse.outputs.run_train }}
      run_prod: ${{ steps.parse.outputs.run_prod }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve inputs
        id: resolve
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            SRC_IMAGE='${{ github.event.client_payload.image }}'
            SRC_REPO='${{ github.event.client_payload.sourceRepo }}'
          else
            SRC_IMAGE='${{ inputs.image }}'
            SRC_REPO='${{ inputs.sourceRepo }}'
          fi
          if [ -z "$SRC_IMAGE" ]; then echo "No source image provided" >&2; exit 1; fi
          if [ -z "$SRC_REPO" ]; then SRC_REPO='${{ vars.FRONTEND_REPO }}'; fi
          if [ -z "$SRC_REPO" ]; then SRC_REPO='${{ github.repository }}'; fi
          echo "srcImage=$SRC_IMAGE" >> "$GITHUB_OUTPUT"
          echo "srcRepo=$SRC_REPO" >> "$GITHUB_OUTPUT"

      - name: Parse base environment from image
        id: parse
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ steps.resolve.outputs.srcImage }}'
          PATH_PART="${SRC_IMAGE#*/}"
          REPO_PART="${PATH_PART%@*}"
          # Expect repo like raptor/frontend-<env>
          if echo "$REPO_PART" | grep -qE 'frontend-(dev|test|train|prod)'; then
            BASE_ENV=$(printf '%s' "$REPO_PART" | sed -nE 's@.*frontend-((dev|test|train|prod)).*@\1@p')
          else
            # Fallback: default to 'dev'
            BASE_ENV=dev
          fi
          RUN_TEST=false
          RUN_TRAIN=false
          RUN_PROD=false
          case "$BASE_ENV" in
            dev)
              RUN_TEST=true; RUN_TRAIN=true; RUN_PROD=true;;
            test)
              RUN_TRAIN=true; RUN_PROD=true;;
            train)
              RUN_PROD=true;;
            prod)
              :;;
          esac
          echo "baseEnv=$BASE_ENV" >> "$GITHUB_OUTPUT"
          echo "run_test=$RUN_TEST" >> "$GITHUB_OUTPUT"
          echo "run_train=$RUN_TRAIN" >> "$GITHUB_OUTPUT"
          echo "run_prod=$RUN_PROD" >> "$GITHUB_OUTPUT"

  prepare-and-notify-test:
    name: Prepare & Notify (test)
    if: ${{ needs.plan.outputs.run_test == 'true' }}
    needs: plan
    environment: preflight
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: test
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
      SRC_REPO: ${{ needs.plan.outputs.srcRepo }}
      FRONTEND_REPO_READ_TOKEN: ${{ secrets.FRONTEND_REPO_READ_TOKEN }}
      MAIL_SERVER: ${{ secrets.MAIL_SERVER }}
      MAIL_PORT: ${{ secrets.MAIL_PORT }}
      MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
      MAIL_TO: ${{ secrets.MAIL_TO }}
      MAIL_FROM: ${{ secrets.MAIL_FROM }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          allow-no-subscriptions: true

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV='${{ env.TARGET_ENV }}'
          # Prefer explicitly configured values from the GitHub Environment; fall back to conventional names
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP || '' }}'
          if [ -z "$RG" ]; then RG="rg-raptor-${TARGET_ENV}"; fi
          SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          LOC=$(az group show -n "$RG" ${SUB:+--subscription "$SUB"} --query location -o tsv 2>/dev/null || true)
          [ -n "$ACR_NAME" ] && echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          [ -n "$LOC" ] && echo "loc=$LOC" >> $GITHUB_OUTPUT
          [ -n "$SUB" ] && echo "sub=$SUB" >> $GITHUB_OUTPUT
          echo "srcRepo=${{ env.SRC_REPO }}" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Capture current deployed image (before promotion)
        id: current
        shell: bash
        run: |
          set -euo pipefail
          ENV='${{ steps.prep.outputs.env }}'
          RG='${{ steps.prep.outputs.rg }}'
          SUB='${{ steps.prep.outputs.sub }}'
          if [ -z "$SUB" ]; then SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'; fi
          if [ -z "$SUB" ]; then
            SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          az extension add -n containerapp -y >/dev/null 2>&1 || true
          CURR_IMG=$(az containerapp show -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} --query "properties.template.containers[0].image" -o tsv 2>/dev/null || true)
          CURR_DIGEST="${CURR_IMG#*@}"
          # If image isn't in digest form (no '@'), leave digest empty so downstream fallback logic runs
          if [ "$CURR_IMG" = "$CURR_DIGEST" ]; then CURR_DIGEST=""; fi
          echo "image=$CURR_IMG" >> $GITHUB_OUTPUT
          echo "digest=$CURR_DIGEST" >> $GITHUB_OUTPUT
          echo "image=$CURR_IMG"
          echo "digest=$CURR_DIGEST"

      - name: Generate release notes
        id: relnotes
        shell: bash
        env:
          SRC_IMAGE: ${{ env.SRC_IMAGE }}
        run: |
          set -euo pipefail
          SRC_IMAGE="$SRC_IMAGE"
          NEW_DIGEST="${SRC_IMAGE#*@}"
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          SRC_REPO="${SRC_PATH%@*}"
          TGT_ENV='${{ steps.prep.outputs.env }}'
          TGT_ACR='${{ steps.prep.outputs.acr }}'
          TGT_REPO="raptor/frontend-${TGT_ENV}"
          AZ_READY=0
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if az account show -o none >/dev/null 2>&1; then AZ_READY=1; fi
          PREV_IMAGE='${{ steps.current.outputs.image }}'
          PREV_DIGEST='${{ steps.current.outputs.digest }}'
          if [ -z "$PREV_DIGEST" ] && [ -n "$PREV_IMAGE" ]; then
            PREV_DOMAIN="${PREV_IMAGE%%/*}"
            PREV_REG=$(echo "$PREV_DOMAIN" | sed 's/\.azurecr\.io$//')
            PREV_PATH="${PREV_IMAGE#*/}"
            # Split repo[:tag] or repo@digest into components
            if echo "$PREV_PATH" | grep -q '@'; then
              PREV_REPO="${PREV_PATH%@*}"
              PREV_TAG=""
            else
              PREV_REPO="${PREV_PATH%%:*}"
              if echo "$PREV_PATH" | grep -q ':'; then PREV_TAG="${PREV_PATH#*:}"; else PREV_TAG=""; fi
            fi
            if [ -n "$TGT_ACR" ] && [ "$PREV_REG" = "$TGT_ACR" ] && [ -n "$PREV_TAG" ] && [ "$AZ_READY" -eq 1 ]; then
              CANDIDATE=$(az acr repository show-manifests -n "$TGT_ACR" --subscription "$SUB" --repository "$PREV_REPO" --query "[?contains(join(',', tags), '$PREV_TAG')].digest | [0]" -o tsv 2>/dev/null || true)
              if [ -n "$CANDIDATE" ]; then PREV_DIGEST="$CANDIDATE"; fi
            fi
          fi
          # Derive previous registry/repo from the actual deployed image for accurate commit lookup
          if [ -n "$PREV_IMAGE" ]; then
            PREV_DOMAIN="${PREV_IMAGE%%/*}"
            PREV_REG_NAME=$(echo "$PREV_DOMAIN" | sed 's/\.azurecr\.io$//')
            PREV_PATH="${PREV_IMAGE#*/}"
            PREV_REPO_NAME="${PREV_PATH%@*}"
          fi
          if [ -z "$PREV_DIGEST" ] && [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ] && [ -n "$TGT_ACR" ] && [ -n "$TGT_REPO" ] && [ "$AZ_READY" -eq 1 ]; then
            LATEST=$(az acr repository show-manifests -n "$TGT_ACR" --subscription "$SUB" --repository "$TGT_REPO" --orderby time_desc --top 1 --query "[0].digest" -o tsv 2>/dev/null || true)
            [ -n "$LATEST" ] && PREV_DIGEST="$LATEST"
          fi
          get_commit_from_labels() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then echo ""; return 0; fi
            local tok
            tok=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            [ -z "$tok" ] && { echo ""; return 0; }
            local base="https://${reg}.azurecr.io/v2/${repo}"
            local mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json' "$base/manifests/$dig" 2>/dev/null || true)
            [ -z "$mf" ] && { echo ""; return 0; }
            local media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')
            if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
              local child=$(printf '%s' "$mf" | jq -r '.manifests[0].digest // empty')
              [ -n "$child" ] && mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$base/manifests/$child" 2>/dev/null || true)
            fi
            local cfg=$(printf '%s' "$mf" | jq -r '.config.digest // empty')
            [ -z "$cfg" ] && { echo ""; return 0; }
            local cfgJson=$(curl -fsSL -H "Authorization: Bearer $tok" "$base/blobs/$cfg" 2>/dev/null || true)
            [ -z "$cfgJson" ] && { echo ""; return 0; }
            local rev=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
            printf '%s' "$rev"
          }
          NEW_COMMIT_SHORT=""
          PREV_COMMIT_SHORT=""
          if [ -n "$NEW_DIGEST" ]; then
            C=$(get_commit_from_labels "$SRC_REG_NAME" "$SRC_REPO" "$NEW_DIGEST")
            [ -n "$C" ] && NEW_COMMIT_SHORT="${C:0:7}" && NEW_SHA="$C"
          fi
          if [ -z "$PREV_COMMIT_SHORT" ] && [ -n "$PREV_DIGEST" ]; then
            # Try the actual previous image registry/repo first
            if [ -n "${PREV_REG_NAME:-}" ] && [ -n "${PREV_REPO_NAME:-}" ]; then C=$(get_commit_from_labels "$PREV_REG_NAME" "$PREV_REPO_NAME" "$PREV_DIGEST"); fi
            # Fall back to target ACR/repo
            if [ -z "${C:-}" ] && [ -n "$TGT_ACR" ]; then C=$(get_commit_from_labels "$TGT_ACR" "$TGT_REPO" "$PREV_DIGEST"); fi
            # Fall back to source image registry/repo
            [ -z "${C:-}" ] && C=$(get_commit_from_labels "$SRC_REG_NAME" "$SRC_REPO" "$PREV_DIGEST")
            [ -n "$C" ] && PREV_COMMIT_SHORT="${C:0:7}" && PREV_SHA="$C"
          fi
          # Fallback: try reading last deployment metadata from Container App tags
          if [ "$AZ_READY" -eq 1 ]; then
            RG='${{ steps.prep.outputs.rg }}'
            APP_NAME=$(echo "${TGT_ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            TAGS_JSON=$(az resource show -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} --resource-type "Microsoft.App/containerApps" --query "tags" -o json 2>/dev/null || true)
            if [ -n "$TAGS_JSON" ] && [ "$TAGS_JSON" != "null" ]; then
              TAGS_DIGEST=$(printf '%s' "$TAGS_JSON" | jq -r '."raptor.lastDigest" // empty')
              TAGS_COMMIT=$(printf '%s' "$TAGS_JSON" | jq -r '."raptor.lastCommit" // empty')
              if [ -z "$PREV_DIGEST" ] && [ -n "$TAGS_DIGEST" ]; then PREV_DIGEST="$TAGS_DIGEST"; fi
              if [ -z "$PREV_COMMIT_SHORT" ] && [ -n "$TAGS_COMMIT" ]; then PREV_COMMIT_SHORT="${TAGS_COMMIT:0:7}"; PREV_SHA="$TAGS_COMMIT"; fi
            fi
          fi
          # If unable to resolve previous commit, KEEP the previous digest; we'll show digest-only notes
          if [ -n "$PREV_DIGEST" ] && [ -z "$PREV_COMMIT_SHORT" ]; then
            echo "[preflight] Previous digest not resolvable to commit; proceeding with digest-only changelog."
          fi
          REPO_URL="https://github.com/${{ env.SRC_REPO }}"
          BUILD_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          NOTES_FILE="release-notes.md"
          HTML_FILE="release-notes.html"
          {
            echo "## Release notes: Promote frontend to ${TGT_ENV}"
            echo
            echo "- Target environment: ${TGT_ENV}"
            echo "- New image: ${SRC_IMAGE}"
            if [ -n "$PREV_DIGEST" ]; then
              echo "- Previously deployed digest: ${PREV_DIGEST}"
            else
              echo "- Previously deployed digest: (none - first promotion)"
            fi
            echo
            if [ -n "${NEW_SHA:-$NEW_COMMIT_SHORT}" ] && [ -n "${PREV_SHA:-$PREV_COMMIT_SHORT}" ]; then
              echo "### Changes (${PREV_COMMIT_SHORT} → ${NEW_COMMIT_SHORT})"
              echo
              echo "Compare: ${REPO_URL}/compare/${PREV_SHA:-$PREV_COMMIT_SHORT}...${NEW_SHA:-$NEW_COMMIT_SHORT}"
            else
              echo "Commit SHAs not available from image labels. Showing image digests only."
            fi
          } > "$NOTES_FILE"
          printf '<h2>Release notes: Promote frontend to %s</h2>\n<p><strong>Target environment:</strong> %s</p>\n<p><strong>New image:</strong> %s</p>\n' "$TGT_ENV" "$TGT_ENV" "$SRC_IMAGE" > "$HTML_FILE"
          if [ -n "$PREV_DIGEST" ]; then echo "<p><strong>Previously deployed digest:</strong> ${PREV_DIGEST}</p>" >> "$HTML_FILE"; else echo "<p><strong>Previously deployed digest:</strong> (none - first promotion)</p>" >> "$HTML_FILE"; fi
          echo "<p><a href=\"${BUILD_URL}\">Build details</a></p>" >> "$HTML_FILE"
          # Render a digest-based Changes block for HTML
          if [ -n "$PREV_DIGEST" ]; then
            echo "<h3>Changes</h3>" >> "$HTML_FILE"
            printf '<p>Digest change: <code>%s</code> → <code>%s</code></p>\n' "$PREV_DIGEST" "$NEW_DIGEST" >> "$HTML_FILE"
            if [ -n "${NEW_SHA:-$NEW_COMMIT_SHORT}" ] && [ -n "${PREV_SHA:-$PREV_COMMIT_SHORT}" ]; then
              printf '<p>Compare commits: <a href="%s/compare/%s...%s">%s → %s</a></p>\n' "$REPO_URL" "${PREV_SHA:-$PREV_COMMIT_SHORT}" "${NEW_SHA:-$NEW_COMMIT_SHORT}" "${PREV_COMMIT_SHORT}" "${NEW_COMMIT_SHORT}" >> "$HTML_FILE"
            else
              echo "<p>Commit SHAs not available from image labels.</p>" >> "$HTML_FILE"
            fi
          fi
          {
            echo 'body<<EOF'
            cat "$NOTES_FILE"
            echo 'EOF'
            echo 'html<<EOF'
            cat "$HTML_FILE"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          cat "$NOTES_FILE" >> "$GITHUB_STEP_SUMMARY"
          printf '\n<!-- Rendered HTML changelog -->\n' >> "$GITHUB_STEP_SUMMARY"
          cat "$HTML_FILE" >> "$GITHUB_STEP_SUMMARY"

      - name: Check email prerequisites
        shell: bash
        run: |
          set -euo pipefail
          missing=()
          for v in MAIL_SERVER MAIL_USERNAME MAIL_PASSWORD MAIL_TO; do
            if [ -z "${!v:-}" ]; then missing+=("$v"); fi
          done
          if [ ${#missing[@]} -gt 0 ]; then
            echo "Email will be skipped. Missing variables: ${missing[*]}"
          else
            echo "Email prerequisites present."
          fi

      - name: Email approver (optional)
        if: ${{ env.MAIL_SERVER && env.MAIL_USERNAME && env.MAIL_PASSWORD && env.MAIL_TO }}
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ env.MAIL_SERVER }}
          server_port: ${{ env.MAIL_PORT || 587 }}
          username: ${{ env.MAIL_USERNAME }}
          password: ${{ env.MAIL_PASSWORD }}
          subject: "[Approval Needed] Promote frontend to ${{ steps.prep.outputs.env }}"
          to: ${{ env.MAIL_TO }}
          from: "${{ env.MAIL_FROM || format('github-actions@{0}', github.repository_owner) }}"
          html_body: |-
            <p>A deployment to the '<strong>${{ steps.prep.outputs.env }}</strong>' environment is pending approval.</p>
            <p><strong>Image:</strong> ${{ env.SRC_IMAGE }}<br>
               <strong>Target:</strong> Azure Container Apps (${{ steps.prep.outputs.env }})</p>
            <p><a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">Build details</a> •
               <a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">Review &amp; approve</a></p>
            ${{ steps.relnotes.outputs.html }}

  promote-to-test:
    name: Promote to test
    if: ${{ needs.plan.outputs.run_test == 'true' }}
    runs-on: ubuntu-latest
    needs: [plan, prepare-and-notify-test]
    environment: test
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: test
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV=${TARGET_ENV}
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP }}'
          if [ -z "$ACR_NAME" ] || [ -z "$RG" ]; then
            echo "Missing AZURE_ACR_NAME or AZURE_RESOURCE_GROUP for '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          LOC=$(az group show -n "$RG" --query location -o tsv 2>/dev/null || true)
          if [ -z "$LOC" ]; then
            echo "Could not resolve location for resource group '$RG' in '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          echo "loc=$LOC" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Ensure target ACR exists
        shell: bash
        run: |
          set -euo pipefail
          ACR='${{ steps.prep.outputs.acr }}'
          # Prefer override RG when provided for cross-RG ACR
          ACR_RG='${{ vars.AZURE_ACR_RESOURCE_GROUP }}'
          if [ -z "$ACR_RG" ]; then ACR_RG='${{ steps.prep.outputs.rg }}'; fi
          echo "Ensuring ACR '$ACR' exists in resource group '$ACR_RG'"
          az acr show -n "$ACR" -g "$ACR_RG" >/dev/null 2>&1 || az acr create -n "$ACR" -g "$ACR_RG" --sku Standard >/dev/null

      - name: Import manifest into target ACR repo
        id: import
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          ACR='${{ steps.prep.outputs.acr }}'
          TARGET_REPO="raptor/frontend-${{ steps.prep.outputs.env }}"
          TAG="promoted-${GITHUB_RUN_ID}"
          echo "Importing $SRC_IMAGE -> $ACR/$TARGET_REPO:$TAG"
          az acr import -n "$ACR" --source "$SRC_IMAGE" --image "$TARGET_REPO:$TAG"
          DIGEST="${SRC_IMAGE#*@}"
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Prepare azd env
        shell: bash
        run: |
          set -euo pipefail
          azd config set alpha.deployment.stacks on
          azd env new ${{ steps.prep.outputs.env }} --no-prompt || true
          azd env set AZURE_ENV_NAME "${{ steps.prep.outputs.env }}"
          azd env set AZURE_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          azd env set AZURE_SUBSCRIPTION_ID "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          azd env set AZURE_ACR_NAME "${{ steps.prep.outputs.acr }}"
          # Pass cross-RG override for ACR when configured
          if [ -n "${{ vars.AZURE_ACR_RESOURCE_GROUP }}" ]; then
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ vars.AZURE_ACR_RESOURCE_GROUP }}"
          else
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          fi
          azd env set SERVICE_FRONTEND_IMAGE_NAME "${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false

      - name: Fast image-only update (skip provision when possible)
        id: fastpath_test
        shell: bash
        run: |
          set -euo pipefail
          APP_NAME=$(echo "${{ steps.prep.outputs.env }}-rap-fe" | tr '[:upper:]' '[:lower:]')
          IMG="${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          DIGEST_PART="${IMG#*@}"
          if [ "$IMG" = "$DIGEST_PART" ]; then
            echo "Image is not digest-form; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          if ! az containerapp show -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" >/dev/null 2>&1; then
            echo "Container App does not exist; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Performing direct image update to: $IMG"
          az containerapp update -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" --image "$IMG"
          echo "didFastPath=true" >> $GITHUB_OUTPUT

      - name: Make preprovision hooks executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x ./scripts/ensure-acr.sh

      - name: Deploy to ${{ steps.prep.outputs.env }}
        if: steps.fastpath_test.outputs.didFastPath != 'true'
        run: azd up --no-prompt --environment "${{ steps.prep.outputs.env }}"

      - name: Expose deployment endpoints
        id: expose_endpoints
        shell: bash
        run: |
          set -euo pipefail
          RAW=$(azd env get-value frontendFqdn 2>/dev/null || true)
          FQDN=$(printf '%s' "$RAW" | tr -d '\r' | head -n1)
          if printf '%s' "$FQDN" | grep -qi '^error:'; then FQDN=""; fi
          if [ -z "$FQDN" ]; then
            ENV="${{ steps.prep.outputs.env }}"
            RG="${{ steps.prep.outputs.rg }}"
            APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            az extension add -n containerapp -y >/dev/null 2>&1 || true
            CA_FQDN=$(az containerapp show -n "$APP_NAME" -g "$RG" --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || true)
            if [ "$CA_FQDN" = "null" ]; then CA_FQDN=""; fi
            FQDN=$(printf '%s' "$CA_FQDN" | tr -d '\r' | head -n1)
            if [ -n "$FQDN" ]; then
              azd env set frontendFqdn "$FQDN" >/dev/null || true
            fi
          fi
          if [ -n "$FQDN" ]; then
            echo "frontendFqdn=$FQDN" >> $GITHUB_OUTPUT
            echo "Frontend URL: https://$FQDN"
          else
            echo "Frontend URL not available"
          fi
          {
            echo "### Deployment endpoints"
            echo ""
            if [ -n "$FQDN" ]; then
              echo "- Frontend: https://$FQDN"
            else
              echo "- Frontend: (not available)"
            fi
          } >> $GITHUB_STEP_SUMMARY

      - name: Persist deployment metadata to tags
        shell: bash
        run: |
          set -euo pipefail
          ENV="${{ steps.prep.outputs.env }}"
          RG="${{ steps.prep.outputs.rg }}"
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if [ -z "$SUB" ]; then SUB=$(az account show --query id -o tsv 2>/dev/null || true); fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          NEW_DIGEST='${{ steps.import.outputs.digest }}'
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          SRC_REPO="${SRC_PATH%@*}"
          get_commit_from_labels() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then echo ""; return 0; fi
            local tok
            tok=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            [ -z "$tok" ] && { echo ""; return 0; }
            local base="https://${reg}.azurecr.io/v2/${repo}"
            local mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json' "$base/manifests/$dig" 2>/dev/null || true)
            [ -z "$mf" ] && { echo ""; return 0; }
            local media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')
            if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
              local child=$(printf '%s' "$mf" | jq -r '.manifests[0].digest // empty')
              [ -n "$child" ] && mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$base/manifests/$child" 2>/dev/null || true)
            fi
            local cfg=$(printf '%s' "$mf" | jq -r '.config.digest // empty')
            [ -z "$cfg" ] && { echo ""; return 0; }
            local cfgJson=$(curl -fsSL -H "Authorization: Bearer $tok" "$base/blobs/$cfg" 2>/dev/null || true)
            [ -z "$cfgJson" ] && { echo ""; return 0; }
            local rev=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
            printf '%s' "$rev"
          }
          NEW_SHA=$(get_commit_from_labels "$SRC_REG_NAME" "$SRC_REPO" "$NEW_DIGEST")
          echo "Updating tags on Container App '$APP_NAME' in RG '$RG'"
          if [ -z "$NEW_DIGEST" ]; then echo "No digest to persist; skipping tag update."; exit 0; fi
          TAG_ARGS=("raptor.lastDigest=${NEW_DIGEST}")
          if [ -n "$NEW_SHA" ]; then TAG_ARGS+=("raptor.lastCommit=${NEW_SHA}"); fi
          az resource tag -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} \
            --resource-type "Microsoft.App/containerApps" \
            --is-incremental \
            --tags "${TAG_ARGS[@]}" >/dev/null

  prepare-and-notify-train:
    name: Prepare & Notify (train)
    if: ${{ needs.plan.outputs.run_train == 'true' }}
    needs: after-test
    environment: preflight
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: train
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
      SRC_REPO: ${{ needs.plan.outputs.srcRepo }}
      FRONTEND_REPO_READ_TOKEN: ${{ secrets.FRONTEND_REPO_READ_TOKEN }}
      MAIL_SERVER: ${{ secrets.MAIL_SERVER }}
      MAIL_PORT: ${{ secrets.MAIL_PORT }}
      MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
      MAIL_TO: ${{ secrets.MAIL_TO }}
      MAIL_FROM: ${{ secrets.MAIL_FROM }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          allow-no-subscriptions: true

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV='${{ env.TARGET_ENV }}'
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP || '' }}'
          if [ -z "$RG" ]; then RG="rg-raptor-${TARGET_ENV}"; fi
          SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          LOC=$(az group show -n "$RG" ${SUB:+--subscription "$SUB"} --query location -o tsv 2>/dev/null || true)
          [ -n "$ACR_NAME" ] && echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          [ -n "$LOC" ] && echo "loc=$LOC" >> $GITHUB_OUTPUT
          [ -n "$SUB" ] && echo "sub=$SUB" >> $GITHUB_OUTPUT
          echo "srcRepo=${{ env.SRC_REPO }}" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Capture current deployed image (before promotion)
        id: current
        shell: bash
        run: |
          set -euo pipefail
          ENV='${{ steps.prep.outputs.env }}'
          RG='${{ steps.prep.outputs.rg }}'
          SUB='${{ steps.prep.outputs.sub }}'
          if [ -z "$SUB" ]; then SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'; fi
          if [ -z "$SUB" ]; then
            SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          az extension add -n containerapp -y >/dev/null 2>&1 || true
          CURR_IMG=$(az containerapp show -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} --query "properties.template.containers[0].image" -o tsv 2>/dev/null || true)
          CURR_DIGEST="${CURR_IMG#*@}"
          if [ "$CURR_IMG" = "$CURR_DIGEST" ]; then CURR_DIGEST=""; fi
          echo "image=$CURR_IMG" >> $GITHUB_OUTPUT
          echo "digest=$CURR_DIGEST" >> $GITHUB_OUTPUT

      - name: Generate release notes
        id: relnotes
        shell: bash
        env:
          SRC_IMAGE: ${{ env.SRC_IMAGE }}
        run: |
          set -euo pipefail
          SRC_IMAGE="$SRC_IMAGE"
          NEW_DIGEST="${SRC_IMAGE#*@}"
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          SRC_REPO="${SRC_PATH%@*}"
          TGT_ENV='${{ steps.prep.outputs.env }}'
          TGT_ACR='${{ steps.prep.outputs.acr }}'
          TGT_REPO="raptor/frontend-${TGT_ENV}"
          AZ_READY=0
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if az account show -o none >/dev/null 2>&1; then AZ_READY=1; fi
          PREV_IMAGE='${{ steps.current.outputs.image }}'
          PREV_DIGEST='${{ steps.current.outputs.digest }}'
          if [ -z "$PREV_DIGEST" ] && [ -n "$PREV_IMAGE" ]; then
            PREV_DOMAIN="${PREV_IMAGE%%/*}"
            PREV_REG=$(echo "$PREV_DOMAIN" | sed 's/\.azurecr\.io$//')
            PREV_PATH="${PREV_IMAGE#*/}"
            PREV_REPO="${PREV_PATH%@*}"
            PREV_TAG="${PREV_PATH#*:}"
            if [ -n "$TGT_ACR" ] && [ "$PREV_REG" = "$TGT_ACR" ] && [ -n "$PREV_TAG" ] && [ "$AZ_READY" -eq 1 ]; then
              CANDIDATE=$(az acr repository show-manifests -n "$TGT_ACR" --subscription "$SUB" --repository "$PREV_REPO" --query "[?contains(join(',', tags), '$PREV_TAG')].digest | [0]" -o tsv 2>/dev/null || true)
              if [ -n "$CANDIDATE" ]; then PREV_DIGEST="$CANDIDATE"; fi
            fi
          fi
          if [ -z "$PREV_DIGEST" ] && [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ] && [ -n "$TGT_ACR" ] && [ -n "$TGT_REPO" ] && [ "$AZ_READY" -eq 1 ]; then
            LATEST=$(az acr repository show-manifests -n "$TGT_ACR" --subscription "$SUB" --repository "$TGT_REPO" --orderby time_desc --top 1 --query "[0].digest" -o tsv 2>/dev/null || true)
            [ -n "$LATEST" ] && PREV_DIGEST="$LATEST"
          fi
          get_commit_from_labels() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then echo ""; return 0; fi
            local tok
            tok=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            [ -z "$tok" ] && { echo ""; return 0; }
            local base="https://${reg}.azurecr.io/v2/${repo}"
            local mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json' "$base/manifests/$dig" 2>/dev/null || true)
            [ -z "$mf" ] && { echo ""; return 0; }
            local media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')
            if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
              local child=$(printf '%s' "$mf" | jq -r '.manifests[0].digest // empty')
              [ -n "$child" ] && mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$base/manifests/$child" 2>/dev/null || true)
            fi
            local cfg=$(printf '%s' "$mf" | jq -r '.config.digest // empty')
            [ -z "$cfg" ] && { echo ""; return 0; }
            local cfgJson=$(curl -fsSL -H "Authorization: Bearer $tok" "$base/blobs/$cfg" 2>/dev/null || true)
            [ -z "$cfgJson" ] && { echo ""; return 0; }
            local rev=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
            printf '%s' "$rev"
          }
          NEW_COMMIT_SHORT=""
          PREV_COMMIT_SHORT=""
          if [ -n "$NEW_DIGEST" ]; then
            C=$(get_commit_from_labels "$SRC_REG_NAME" "$SRC_REPO" "$NEW_DIGEST")
            [ -n "$C" ] && NEW_COMMIT_SHORT="${C:0:7}" && NEW_SHA="$C"
          fi
          if [ -z "$PREV_COMMIT_SHORT" ] && [ -n "$PREV_DIGEST" ]; then
            if [ -n "$TGT_ACR" ]; then C=$(get_commit_from_labels "$TGT_ACR" "$TGT_REPO" "$PREV_DIGEST"); fi
            [ -z "${C:-}" ] && C=$(get_commit_from_labels "$SRC_REG_NAME" "$SRC_REPO" "$PREV_DIGEST")
            [ -n "$C" ] && PREV_COMMIT_SHORT="${C:0:7}" && PREV_SHA="$C"
          fi
          # Fallback: try reading last deployment metadata from Container App tags
          if [ "$AZ_READY" -eq 1 ]; then
            RG='${{ steps.prep.outputs.rg }}'
            APP_NAME=$(echo "${TGT_ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            TAGS_JSON=$(az resource show -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} --resource-type "Microsoft.App/containerApps" --query "tags" -o json 2>/dev/null || true)
            if [ -n "$TAGS_JSON" ] && [ "$TAGS_JSON" != "null" ]; then
              TAGS_DIGEST=$(printf '%s' "$TAGS_JSON" | jq -r '."raptor.lastDigest" // empty')
              TAGS_COMMIT=$(printf '%s' "$TAGS_JSON" | jq -r '."raptor.lastCommit" // empty')
              if [ -z "$PREV_DIGEST" ] && [ -n "$TAGS_DIGEST" ]; then PREV_DIGEST="$TAGS_DIGEST"; fi
              if [ -z "$PREV_COMMIT_SHORT" ] && [ -n "$TAGS_COMMIT" ]; then PREV_COMMIT_SHORT="${TAGS_COMMIT:0:7}"; PREV_SHA="$TAGS_COMMIT"; fi
            fi
          fi
          # If still unable to resolve previous commit, treat as first promotion baseline
          if [ -n "$PREV_DIGEST" ] && [ -z "$PREV_COMMIT_SHORT" ]; then
            echo "[preflight] Previous digest not resolvable to commit; treating as first promotion baseline."
            PREV_DIGEST=""
          fi
          REPO_URL="https://github.com/${{ env.SRC_REPO }}"
          BUILD_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          NOTES_FILE="release-notes.md"
          HTML_FILE="release-notes.html"
          {
            echo "## Release notes: Promote frontend to ${TGT_ENV}"
            echo
            echo "- Target environment: ${TGT_ENV}"
            echo "- New image: ${SRC_IMAGE}"
            if [ -n "$PREV_DIGEST" ]; then
              echo "- Previously deployed digest: ${PREV_DIGEST}"
            else
              echo "- Previously deployed digest: (none - first promotion)"
            fi
            echo
            if [ -n "${NEW_SHA:-$NEW_COMMIT_SHORT}" ] && [ -n "${PREV_SHA:-$PREV_COMMIT_SHORT}" ]; then
              echo "### Changes (${PREV_COMMIT_SHORT} → ${NEW_COMMIT_SHORT})"
              echo
              echo "Compare: ${REPO_URL}/compare/${PREV_SHA:-$PREV_COMMIT_SHORT}...${NEW_SHA:-$NEW_COMMIT_SHORT}"
            else
              echo "Could not resolve commit SHAs from image tags. Showing image digests only."
            fi
          } > "$NOTES_FILE"
          printf '<h2>Release notes: Promote frontend to %s</h2>\n<p><strong>Target environment:</strong> %s</p>\n<p><strong>New image:</strong> %s</p>\n' "$TGT_ENV" "$TGT_ENV" "$SRC_IMAGE" > "$HTML_FILE"
          if [ -n "$PREV_DIGEST" ]; then echo "<p><strong>Previously deployed digest:</strong> ${PREV_DIGEST}</p>" >> "$HTML_FILE"; else echo "<p><strong>Previously deployed digest:</strong> (none - first promotion)</p>" >> "$HTML_FILE"; fi
          echo "<p><a href=\"${BUILD_URL}\">Build details</a></p>" >> "$HTML_FILE"
          {
            echo 'body<<EOF'
            cat "$NOTES_FILE"
            echo 'EOF'
            echo 'html<<EOF'
            cat "$HTML_FILE"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          cat "$NOTES_FILE" >> "$GITHUB_STEP_SUMMARY"
          printf '\n<!-- Rendered HTML changelog -->\n' >> "$GITHUB_STEP_SUMMARY"
          cat "$HTML_FILE" >> "$GITHUB_STEP_SUMMARY"

      - name: Check email prerequisites
        shell: bash
        run: |
          set -euo pipefail
          missing=()
          for v in MAIL_SERVER MAIL_USERNAME MAIL_PASSWORD MAIL_TO; do
            if [ -z "${!v:-}" ]; then missing+=("$v"); fi
          done
          if [ ${#missing[@]} -gt 0 ]; then
            echo "Email will be skipped. Missing variables: ${missing[*]}"
          else
            echo "Email prerequisites present."
          fi

      - name: Email approver (optional)
        if: ${{ env.MAIL_SERVER && env.MAIL_USERNAME && env.MAIL_PASSWORD && env.MAIL_TO }}
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ env.MAIL_SERVER }}
          server_port: ${{ env.MAIL_PORT || 587 }}
          username: ${{ env.MAIL_USERNAME }}
          password: ${{ env.MAIL_PASSWORD }}
          subject: "[Approval Needed] Promote frontend to ${{ steps.prep.outputs.env }}"
          to: ${{ env.MAIL_TO }}
          from: "${{ env.MAIL_FROM || format('github-actions@{0}', github.repository_owner) }}"
          html_body: |-
            <p>A deployment to the '<strong>${{ steps.prep.outputs.env }}</strong>' environment is pending approval.</p>
            <p><strong>Image:</strong> ${{ env.SRC_IMAGE }}<br>
               <strong>Target:</strong> Azure Container Apps (${{ steps.prep.outputs.env }})</p>
            <p><a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">Build details</a> •
               <a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">Review &amp; approve</a></p>
            ${{ steps.relnotes.outputs.html }}

  after-test:
    name: Barrier after test
    if: ${{ always() }}
    needs: [plan, promote-to-test]
    runs-on: ubuntu-latest
    steps:
      - run: echo "Proceeding to train stage"

  promote-to-train:
    name: Promote to train
    if: ${{ needs.plan.outputs.run_train == 'true' }}
    runs-on: ubuntu-latest
    needs: [plan, prepare-and-notify-train]
    environment: train
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: train
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV=${TARGET_ENV}
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP }}'
          if [ -z "$ACR_NAME" ] || [ -z "$RG" ]; then
            echo "Missing AZURE_ACR_NAME or AZURE_RESOURCE_GROUP for '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          LOC=$(az group show -n "$RG" --query location -o tsv 2>/dev/null || true)
          if [ -z "$LOC" ]; then
            echo "Could not resolve location for resource group '$RG' in '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          echo "loc=$LOC" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Ensure target ACR exists
        shell: bash
        run: |
          set -euo pipefail
          ACR='${{ steps.prep.outputs.acr }}'
          ACR_RG='${{ vars.AZURE_ACR_RESOURCE_GROUP }}'
          if [ -z "$ACR_RG" ]; then ACR_RG='${{ steps.prep.outputs.rg }}'; fi
          echo "Ensuring ACR '$ACR' exists in resource group '$ACR_RG'"
          az acr show -n "$ACR" -g "$ACR_RG" >/dev/null 2>&1 || az acr create -n "$ACR" -g "$ACR_RG" --sku Standard >/dev/null

      - name: Import manifest into target ACR repo
        id: import
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          ACR='${{ steps.prep.outputs.acr }}'
          TARGET_REPO="raptor/frontend-${{ steps.prep.outputs.env }}"
          TAG="promoted-${GITHUB_RUN_ID}"
          echo "Importing $SRC_IMAGE -> $ACR/$TARGET_REPO:$TAG"
          az acr import -n "$ACR" --source "$SRC_IMAGE" --image "$TARGET_REPO:$TAG"
          DIGEST="${SRC_IMAGE#*@}"
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Prepare azd env
        shell: bash
        run: |
          set -euo pipefail
          azd config set alpha.deployment.stacks on
          azd env new ${{ steps.prep.outputs.env }} --no-prompt || true
          azd env set AZURE_ENV_NAME "${{ steps.prep.outputs.env }}"
          azd env set AZURE_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          azd env set AZURE_SUBSCRIPTION_ID "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          azd env set AZURE_ACR_NAME "${{ steps.prep.outputs.acr }}"
          if [ -n "${{ vars.AZURE_ACR_RESOURCE_GROUP }}" ]; then
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ vars.AZURE_ACR_RESOURCE_GROUP }}"
          else
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          fi
          azd env set SERVICE_FRONTEND_IMAGE_NAME "${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false

      - name: Fast image-only update (skip provision when possible)
        id: fastpath_prod
        shell: bash
        run: |
          set -euo pipefail
          APP_NAME=$(echo "${{ steps.prep.outputs.env }}-rap-fe" | tr '[:upper:]' '[:lower:]')
          IMG="${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          DIGEST_PART="${IMG#*@}"
          if [ "$IMG" = "$DIGEST_PART" ]; then
            echo "Image is not digest-form; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          if ! az containerapp show -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" >/dev/null 2>&1; then
            echo "Container App does not exist; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Performing direct image update to: $IMG"
          az containerapp update -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" --image "$IMG"
          echo "didFastPath=true" >> $GITHUB_OUTPUT

      - name: Fast image-only update (skip provision when possible)
        id: fastpath_train
        shell: bash
        run: |
          set -euo pipefail
          APP_NAME=$(echo "${{ steps.prep.outputs.env }}-rap-fe" | tr '[:upper:]' '[:lower:]')
          IMG="${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          DIGEST_PART="${IMG#*@}"
          if [ "$IMG" = "$DIGEST_PART" ]; then
            echo "Image is not digest-form; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          if ! az containerapp show -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" >/dev/null 2>&1; then
            echo "Container App does not exist; cannot fast-path."
            echo "didFastPath=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Performing direct image update to: $IMG"
          az containerapp update -n "$APP_NAME" -g "${{ steps.prep.outputs.rg }}" --image "$IMG"
          echo "didFastPath=true" >> $GITHUB_OUTPUT

      - name: Make preprovision hooks executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x ./scripts/ensure-acr.sh

      - name: Deploy to ${{ steps.prep.outputs.env }}
        if: steps.fastpath_train.outputs.didFastPath != 'true'
        run: azd up --no-prompt --environment "${{ steps.prep.outputs.env }}"

      - name: Expose deployment endpoints
        id: expose_endpoints
        shell: bash
        run: |
          set -euo pipefail
          RAW=$(azd env get-value frontendFqdn 2>/dev/null || true)
          FQDN=$(printf '%s' "$RAW" | tr -d '\r' | head -n1)
          if printf '%s' "$FQDN" | grep -qi '^error:'; then FQDN=""; fi
          if [ -z "$FQDN" ]; then
            ENV="${{ steps.prep.outputs.env }}"
            RG="${{ steps.prep.outputs.rg }}"
            APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            az extension add -n containerapp -y >/dev/null 2>&1 || true
            CA_FQDN=$(az containerapp show -n "$APP_NAME" -g "$RG" --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || true)
            if [ "$CA_FQDN" = "null" ]; then CA_FQDN=""; fi
            FQDN=$(printf '%s' "$CA_FQDN" | tr -d '\r' | head -n1)
            if [ -n "$FQDN" ]; then
              azd env set frontendFqdn "$FQDN" >/dev/null || true
            fi
          fi
          if [ -n "$FQDN" ]; then
            echo "frontendFqdn=$FQDN" >> $GITHUB_OUTPUT
            echo "Frontend URL: https://$FQDN"
          else
            echo "Frontend URL not available"
          fi
          {
            echo "### Deployment endpoints"
            echo ""
            if [ -n "$FQDN" ]; then
              echo "- Frontend: https://$FQDN"
            else
              echo "- Frontend: (not available)"
            fi
          } >> $GITHUB_STEP_SUMMARY

      - name: Persist deployment metadata to tags
        shell: bash
        run: |
          set -euo pipefail
          ENV="${{ steps.prep.outputs.env }}"
          RG="${{ steps.prep.outputs.rg }}"
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if [ -z "$SUB" ]; then SUB=$(az account show --query id -o tsv 2>/dev/null || true); fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          NEW_DIGEST='${{ steps.import.outputs.digest }}'
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          SRC_REPO="${SRC_PATH%@*}"
          get_commit_from_labels() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then echo ""; return 0; fi
            local tok
            tok=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            [ -z "$tok" ] && { echo ""; return 0; }
            local base="https://${reg}.azurecr.io/v2/${repo}"
            local mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json' "$base/manifests/$dig" 2>/dev/null || true)
            [ -z "$mf" ] && { echo ""; return 0; }
            local media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')
            if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
              local child=$(printf '%s' "$mf" | jq -r '.manifests[0].digest // empty')
              [ -n "$child" ] && mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$base/manifests/$child" 2>/dev/null || true)
            fi
            local cfg=$(printf '%s' "$mf" | jq -r '.config.digest // empty')
            [ -z "$cfg" ] && { echo ""; return 0; }
            local cfgJson=$(curl -fsSL -H "Authorization: Bearer $tok" "$base/blobs/$cfg" 2>/dev/null || true)
            [ -z "$cfgJson" ] && { echo ""; return 0; }
            local rev=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
            printf '%s' "$rev"
          }
          NEW_SHA=$(get_commit_from_labels "$SRC_REG_NAME" "$SRC_REPO" "$NEW_DIGEST")
          echo "Updating tags on Container App '$APP_NAME' in RG '$RG'"
          if [ -z "$NEW_DIGEST" ]; then echo "No digest to persist; skipping tag update."; exit 0; fi
          TAG_ARGS=("raptor.lastDigest=${NEW_DIGEST}")
          if [ -n "$NEW_SHA" ]; then TAG_ARGS+=("raptor.lastCommit=${NEW_SHA}"); fi
          az resource tag -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} \
            --resource-type "Microsoft.App/containerApps" \
            --is-incremental \
            --tags "${TAG_ARGS[@]}" >/dev/null

  after-train:
    name: Barrier after train
    if: ${{ always() }}
    needs: [plan, promote-to-train]
    runs-on: ubuntu-latest
    steps:
      - run: echo "Proceeding to prod stage"

  prepare-and-notify-prod:
    name: Prepare & Notify (prod)
    if: ${{ needs.plan.outputs.run_prod == 'true' }}
    needs: after-train
    environment: preflight
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: prod
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
      SRC_REPO: ${{ needs.plan.outputs.srcRepo }}
      FRONTEND_REPO_READ_TOKEN: ${{ secrets.FRONTEND_REPO_READ_TOKEN }}
      MAIL_SERVER: ${{ secrets.MAIL_SERVER }}
      MAIL_PORT: ${{ secrets.MAIL_PORT }}
      MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
      MAIL_TO: ${{ secrets.MAIL_TO }}
      MAIL_FROM: ${{ secrets.MAIL_FROM }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          allow-no-subscriptions: true

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV='${{ env.TARGET_ENV }}'
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP || '' }}'
          if [ -z "$RG" ]; then RG="rg-raptor-${TARGET_ENV}"; fi
          SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          LOC=$(az group show -n "$RG" ${SUB:+--subscription "$SUB"} --query location -o tsv 2>/dev/null || true)
          [ -n "$ACR_NAME" ] && echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          [ -n "$LOC" ] && echo "loc=$LOC" >> $GITHUB_OUTPUT
          [ -n "$SUB" ] && echo "sub=$SUB" >> $GITHUB_OUTPUT
          echo "srcRepo=${{ env.SRC_REPO }}" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Capture current deployed image (before promotion)
        id: current
        shell: bash
        run: |
          set -euo pipefail
          ENV='${{ steps.prep.outputs.env }}'
          RG='${{ steps.prep.outputs.rg }}'
          SUB='${{ steps.prep.outputs.sub }}'
          if [ -z "$SUB" ]; then SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'; fi
          if [ -z "$SUB" ]; then
            SUB=$(az account show --query id -o tsv 2>/dev/null || true)
          fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          az extension add -n containerapp -y >/dev/null 2>&1 || true
          CURR_IMG=$(az containerapp show -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} --query "properties.template.containers[0].image" -o tsv 2>/dev/null || true)
          CURR_DIGEST="${CURR_IMG#*@}"
          if [ "$CURR_IMG" = "$CURR_DIGEST" ]; then CURR_DIGEST=""; fi
          echo "image=$CURR_IMG" >> $GITHUB_OUTPUT
          echo "digest=$CURR_DIGEST" >> $GITHUB_OUTPUT

      - name: Generate release notes
        id: relnotes
        shell: bash
        env:
          SRC_IMAGE: ${{ env.SRC_IMAGE }}
        run: |
          set -euo pipefail
          SRC_IMAGE="$SRC_IMAGE"
          NEW_DIGEST="${SRC_IMAGE#*@}"
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          SRC_REPO="${SRC_PATH%@*}"
          TGT_ENV='${{ steps.prep.outputs.env }}'
          TGT_ACR='${{ steps.prep.outputs.acr }}'
          TGT_REPO="raptor/frontend-${TGT_ENV}"
          AZ_READY=0
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if az account show -o none >/dev/null 2>&1; then AZ_READY=1; fi
          PREV_IMAGE='${{ steps.current.outputs.image }}'
          PREV_DIGEST='${{ steps.current.outputs.digest }}'
          if [ -z "$PREV_DIGEST" ] && [ -n "$PREV_IMAGE" ]; then
            PREV_DOMAIN="${PREV_IMAGE%%/*}"
            PREV_REG=$(echo "$PREV_DOMAIN" | sed 's/\.azurecr\.io$//')
            PREV_PATH="${PREV_IMAGE#*/}"
            PREV_REPO="${PREV_PATH%@*}"
            PREV_TAG="${PREV_PATH#*:}"
            if [ -n "$TGT_ACR" ] && [ "$PREV_REG" = "$TGT_ACR" ] && [ -n "$PREV_TAG" ] && [ "$AZ_READY" -eq 1 ]; then
              CANDIDATE=$(az acr repository show-manifests -n "$TGT_ACR" --subscription "$SUB" --repository "$PREV_REPO" --query "[?contains(join(',', tags), '$PREV_TAG')].digest | [0]" -o tsv 2>/dev/null || true)
              if [ -n "$CANDIDATE" ]; then PREV_DIGEST="$CANDIDATE"; fi
            fi
          fi
          if [ -z "$PREV_DIGEST" ] && [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ] && [ -n "$TGT_ACR" ] && [ -n "$TGT_REPO" ] && [ "$AZ_READY" -eq 1 ]; then
            LATEST=$(az acr repository show-manifests -n "$TGT_ACR" --subscription "$SUB" --repository "$TGT_REPO" --orderby time_desc --top 1 --query "[0].digest" -o tsv 2>/dev/null || true)
            [ -n "$LATEST" ] && PREV_DIGEST="$LATEST"
          fi
          get_commit_from_labels() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then echo ""; return 0; fi
            local tok
            tok=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            [ -z "$tok" ] && { echo ""; return 0; }
            local base="https://${reg}.azurecr.io/v2/${repo}"
            local mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json' "$base/manifests/$dig" 2>/dev/null || true)
            [ -z "$mf" ] && { echo ""; return 0; }
            local media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')
            if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
              local child=$(printf '%s' "$mf" | jq -r '.manifests[0].digest // empty')
              [ -n "$child" ] && mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$base/manifests/$child" 2>/dev/null || true)
            fi
            local cfg=$(printf '%s' "$mf" | jq -r '.config.digest // empty')
            [ -z "$cfg" ] && { echo ""; return 0; }
            local cfgJson=$(curl -fsSL -H "Authorization: Bearer $tok" "$base/blobs/$cfg" 2>/dev/null || true)
            [ -z "$cfgJson" ] && { echo ""; return 0; }
            local rev=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
            printf '%s' "$rev"
          }
          NEW_COMMIT_SHORT=""
          PREV_COMMIT_SHORT=""
          if [ -n "$NEW_DIGEST" ]; then
            C=$(get_commit_from_labels "$SRC_REG_NAME" "$SRC_REPO" "$NEW_DIGEST")
            [ -n "$C" ] && NEW_COMMIT_SHORT="${C:0:7}" && NEW_SHA="$C"
          fi
          if [ -z "$PREV_COMMIT_SHORT" ] && [ -n "$PREV_DIGEST" ]; then
            if [ -n "$TGT_ACR" ]; then C=$(get_commit_from_labels "$TGT_ACR" "$TGT_REPO" "$PREV_DIGEST"); fi
            [ -z "${C:-}" ] && C=$(get_commit_from_labels "$SRC_REG_NAME" "$SRC_REPO" "$PREV_DIGEST")
            [ -n "$C" ] && PREV_COMMIT_SHORT="${C:0:7}" && PREV_SHA="$C"
          fi
          # Fallback: try reading last deployment metadata from Container App tags
          if [ "$AZ_READY" -eq 1 ]; then
            RG='${{ steps.prep.outputs.rg }}'
            APP_NAME=$(echo "${TGT_ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            TAGS_JSON=$(az resource show -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} --resource-type "Microsoft.App/containerApps" --query "tags" -o json 2>/dev/null || true)
            if [ -n "$TAGS_JSON" ] && [ "$TAGS_JSON" != "null" ]; then
              TAGS_DIGEST=$(printf '%s' "$TAGS_JSON" | jq -r '."raptor.lastDigest" // empty')
              TAGS_COMMIT=$(printf '%s' "$TAGS_JSON" | jq -r '."raptor.lastCommit" // empty')
              if [ -z "$PREV_DIGEST" ] && [ -n "$TAGS_DIGEST" ]; then PREV_DIGEST="$TAGS_DIGEST"; fi
              if [ -z "$PREV_COMMIT_SHORT" ] && [ -n "$TAGS_COMMIT" ]; then PREV_COMMIT_SHORT="${TAGS_COMMIT:0:7}"; PREV_SHA="$TAGS_COMMIT"; fi
            fi
          fi
          # If still unable to resolve previous commit, treat as first promotion baseline
          if [ -n "$PREV_DIGEST" ] && [ -z "$PREV_COMMIT_SHORT" ]; then
            echo "[preflight] Previous digest not resolvable to commit; treating as first promotion baseline."
            PREV_DIGEST=""
          fi
          REPO_URL="https://github.com/${{ env.SRC_REPO }}"
          BUILD_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          NOTES_FILE="release-notes.md"
          HTML_FILE="release-notes.html"
          {
            echo "## Release notes: Promote frontend to ${TGT_ENV}"
            echo
            echo "- Target environment: ${TGT_ENV}"
            echo "- New image: ${SRC_IMAGE}"
            if [ -n "$PREV_DIGEST" ]; then
              echo "- Previously deployed digest: ${PREV_DIGEST}"
            else
              echo "- Previously deployed digest: (none - first promotion)"
            fi
            echo
            if [ -n "${NEW_SHA:-$NEW_COMMIT_SHORT}" ] && [ -n "${PREV_SHA:-$PREV_COMMIT_SHORT}" ]; then
              echo "### Changes (${PREV_COMMIT_SHORT} → ${NEW_COMMIT_SHORT})"
              echo
              echo "Compare: ${REPO_URL}/compare/${PREV_SHA:-$PREV_COMMIT_SHORT}...${NEW_SHA:-$NEW_COMMIT_SHORT}"
            else
              echo "Could not resolve commit SHAs from image tags. Showing image digests only."
            fi
          } > "$NOTES_FILE"
          printf '<h2>Release notes: Promote frontend to %s</h2>\n<p><strong>Target environment:</strong> %s</p>\n<p><strong>New image:</strong> %s</p>\n' "$TGT_ENV" "$TGT_ENV" "$SRC_IMAGE" > "$HTML_FILE"
          if [ -n "$PREV_DIGEST" ]; then echo "<p><strong>Previously deployed digest:</strong> ${PREV_DIGEST}</p>" >> "$HTML_FILE"; else echo "<p><strong>Previously deployed digest:</strong> (none - first promotion)</p>" >> "$HTML_FILE"; fi
          echo "<p><a href=\"${BUILD_URL}\">Build details</a></p>" >> "$HTML_FILE"
          {
            echo 'body<<EOF'
            cat "$NOTES_FILE"
            echo 'EOF'
            echo 'html<<EOF'
            cat "$HTML_FILE"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          cat "$NOTES_FILE" >> "$GITHUB_STEP_SUMMARY"
          printf '\n<!-- Rendered HTML changelog -->\n' >> "$GITHUB_STEP_SUMMARY"
          cat "$HTML_FILE" >> "$GITHUB_STEP_SUMMARY"

      - name: Check email prerequisites
        shell: bash
        run: |
          set -euo pipefail
          missing=()
          for v in MAIL_SERVER MAIL_USERNAME MAIL_PASSWORD MAIL_TO; do
            if [ -z "${!v:-}" ]; then missing+=("$v"); fi
          done
          if [ ${#missing[@]} -gt 0 ]; then
            echo "Email will be skipped. Missing variables: ${missing[*]}"
          else
            echo "Email prerequisites present."
          fi

      - name: Email approver (optional)
        if: ${{ env.MAIL_SERVER && env.MAIL_USERNAME && env.MAIL_PASSWORD && env.MAIL_TO }}
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ env.MAIL_SERVER }}
          server_port: ${{ env.MAIL_PORT || 587 }}
          username: ${{ env.MAIL_USERNAME }}
          password: ${{ env.MAIL_PASSWORD }}
          subject: "[Approval Needed] Promote frontend to ${{ steps.prep.outputs.env }}"
          to: ${{ env.MAIL_TO }}
          from: "${{ env.MAIL_FROM || format('github-actions@{0}', github.repository_owner) }}"
          html_body: |-
            <p>A deployment to the '<strong>${{ steps.prep.outputs.env }}</strong>' environment is pending approval.</p>
            <p><strong>Image:</strong> ${{ env.SRC_IMAGE }}<br>
               <strong>Target:</strong> Azure Container Apps (${{ steps.prep.outputs.env }})</p>
            <p><a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">Build details</a> •
               <a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">Review &amp; approve</a></p>
            ${{ steps.relnotes.outputs.html }}

  promote-to-prod:
    name: Promote to prod
    if: ${{ needs.plan.outputs.run_prod == 'true' }}
    runs-on: ubuntu-latest
    needs: [plan, prepare-and-notify-prod]
    environment: prod
    permissions:
      id-token: write
      contents: read
    env:
      TARGET_ENV: prod
      SRC_IMAGE: ${{ needs.plan.outputs.srcImage }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure Developer CLI (azd)
        run: |
          curl -fsSL https://aka.ms/install-azd.sh | bash
          echo "$HOME/.azure-dev/bin" >> $GITHUB_PATH
          azd version

      - name: azd auth login (OIDC via provider)
        run: |
          azd auth login \
            --client-id "${{ secrets.AZURE_CLIENT_ID }}" \
            --tenant-id "${{ secrets.AZURE_TENANT_ID }}" \
            --federated-credential-provider github

      - name: Verify az/azd auth
        shell: bash
        run: |
          set -euo pipefail
          az account show -o none
          az account get-access-token -o none
          command -v azd >/dev/null 2>&1
          azd version

      - name: Prepare target env variables
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          TARGET_ENV=${TARGET_ENV}
          ACR_NAME='${{ vars.AZURE_ACR_NAME }}'
          RG='${{ vars.AZURE_RESOURCE_GROUP }}'
          if [ -z "$ACR_NAME" ] || [ -z "$RG" ]; then
            echo "Missing AZURE_ACR_NAME or AZURE_RESOURCE_GROUP for '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          LOC=$(az group show -n "$RG" --query location -o tsv 2>/dev/null || true)
          if [ -z "$LOC" ]; then
            echo "Could not resolve location for resource group '$RG' in '${TARGET_ENV}' environment." >&2
            exit 1
          fi
          echo "acr=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT
          echo "loc=$LOC" >> $GITHUB_OUTPUT
          echo "env=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Ensure target ACR exists
        shell: bash
        run: |
          set -euo pipefail
          ACR='${{ steps.prep.outputs.acr }}'
          ACR_RG='${{ vars.AZURE_ACR_RESOURCE_GROUP }}'
          if [ -z "$ACR_RG" ]; then ACR_RG='${{ steps.prep.outputs.rg }}'; fi
          echo "Ensuring ACR '$ACR' exists in resource group '$ACR_RG'"
          az acr show -n "$ACR" -g "$ACR_RG" >/dev/null 2>&1 || az acr create -n "$ACR" -g "$ACR_RG" --sku Standard >/dev/null

      - name: Import manifest into target ACR repo
        id: import
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          ACR='${{ steps.prep.outputs.acr }}'
          TARGET_REPO="raptor/frontend-${{ steps.prep.outputs.env }}"
          TAG="promoted-${GITHUB_RUN_ID}"
          echo "Importing $SRC_IMAGE -> $ACR/$TARGET_REPO:$TAG"
          az acr import -n "$ACR" --source "$SRC_IMAGE" --image "$TARGET_REPO:$TAG"
          DIGEST="${SRC_IMAGE#*@}"
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Prepare azd env
        shell: bash
        run: |
          set -euo pipefail
          azd config set alpha.deployment.stacks on
          azd env new ${{ steps.prep.outputs.env }} --no-prompt || true
          azd env set AZURE_ENV_NAME "${{ steps.prep.outputs.env }}"
          azd env set AZURE_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          azd env set AZURE_SUBSCRIPTION_ID "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          azd env set AZURE_ACR_NAME "${{ steps.prep.outputs.acr }}"
          if [ -n "${{ vars.AZURE_ACR_RESOURCE_GROUP }}" ]; then
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ vars.AZURE_ACR_RESOURCE_GROUP }}"
          else
            azd env set AZURE_ACR_RESOURCE_GROUP "${{ steps.prep.outputs.rg }}"
          fi
          azd env set SERVICE_FRONTEND_IMAGE_NAME "${{ steps.prep.outputs.acr }}.azurecr.io/raptor/frontend-${{ steps.prep.outputs.env }}@${{ steps.import.outputs.digest }}"
          azd env set SKIP_ACR_PULL_ROLE_ASSIGNMENT false

      - name: Make preprovision hooks executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x ./scripts/ensure-acr.sh

      - name: Deploy to ${{ steps.prep.outputs.env }}
        if: steps.fastpath_prod.outputs.didFastPath != 'true'
        run: azd up --no-prompt --environment "${{ steps.prep.outputs.env }}"

      - name: Expose deployment endpoints
        id: expose_endpoints
        shell: bash
        run: |
          set -euo pipefail
          RAW=$(azd env get-value frontendFqdn 2>/dev/null || true)
          FQDN=$(printf '%s' "$RAW" | tr -d '\r' | head -n1)
          if printf '%s' "$FQDN" | grep -qi '^error:'; then FQDN=""; fi
          if [ -z "$FQDN" ]; then
            ENV="${{ steps.prep.outputs.env }}"
            RG="${{ steps.prep.outputs.rg }}"
            APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
            az extension add -n containerapp -y >/dev/null 2>&1 || true
            CA_FQDN=$(az containerapp show -n "$APP_NAME" -g "$RG" --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || true)
            if [ "$CA_FQDN" = "null" ]; then CA_FQDN=""; fi
            FQDN=$(printf '%s' "$CA_FQDN" | tr -d '\r' | head -n1)
            if [ -n "$FQDN" ]; then
              azd env set frontendFqdn "$FQDN" >/dev/null || true
            fi
          fi
          if [ -n "$FQDN" ]; then
            echo "frontendFqdn=$FQDN" >> $GITHUB_OUTPUT
            echo "Frontend URL: https://$FQDN"
          else
            echo "Frontend URL not available"
          fi
          {
            echo "### Deployment endpoints"
            echo ""
            if [ -n "$FQDN" ]; then
              echo "- Frontend: https://$FQDN"
            else
              echo "- Frontend: (not available)"
            fi
          } >> $GITHUB_STEP_SUMMARY

      - name: Persist deployment metadata to tags
        shell: bash
        run: |
          set -euo pipefail
          ENV="${{ steps.prep.outputs.env }}"
          RG="${{ steps.prep.outputs.rg }}"
          SUB='${{ secrets.AZURE_SUBSCRIPTION_ID }}'
          if [ -z "$SUB" ]; then SUB=$(az account show --query id -o tsv 2>/dev/null || true); fi
          APP_NAME=$(echo "${ENV}-rap-fe" | tr '[:upper:]' '[:lower:]')
          NEW_DIGEST='${{ steps.import.outputs.digest }}'
          SRC_IMAGE='${{ env.SRC_IMAGE }}'
          SRC_DOMAIN="${SRC_IMAGE%%/*}"
          SRC_REG_NAME=$(echo "$SRC_DOMAIN" | sed 's/\.azurecr\.io$//')
          SRC_PATH="${SRC_IMAGE#*/}"
          SRC_REPO="${SRC_PATH%@*}"
          get_commit_from_labels() {
            local reg="$1" repo="$2" dig="$3"
            if [ -z "$dig" ]; then echo ""; return 0; fi
            local tok
            tok=$(az acr login -n "$reg" --expose-token -o tsv --query accessToken 2>/dev/null || true)
            [ -z "$tok" ] && { echo ""; return 0; }
            local base="https://${reg}.azurecr.io/v2/${repo}"
            local mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.list.v2+json' "$base/manifests/$dig" 2>/dev/null || true)
            [ -z "$mf" ] && { echo ""; return 0; }
            local media=$(printf '%s' "$mf" | jq -r '.mediaType // empty')
            if [ "$media" = "application/vnd.oci.image.index.v1+json" ] || [ "$media" = "application/vnd.docker.distribution.manifest.list.v2+json" ]; then
              local child=$(printf '%s' "$mf" | jq -r '.manifests[0].digest // empty')
              [ -n "$child" ] && mf=$(curl -fsSL -H "Authorization: Bearer $tok" -H 'Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json' "$base/manifests/$child" 2>/dev/null || true)
            fi
            local cfg=$(printf '%s' "$mf" | jq -r '.config.digest // empty')
            [ -z "$cfg" ] && { echo ""; return 0; }
            local cfgJson=$(curl -fsSL -H "Authorization: Bearer $tok" "$base/blobs/$cfg" 2>/dev/null || true)
            [ -z "$cfgJson" ] && { echo ""; return 0; }
            local rev=$(printf '%s' "$cfgJson" | jq -r '.config.Labels["org.opencontainers.image.revision"] // empty')
            printf '%s' "$rev"
          }
          NEW_SHA=$(get_commit_from_labels "$SRC_REG_NAME" "$SRC_REPO" "$NEW_DIGEST")
          echo "Updating tags on Container App '$APP_NAME' in RG '$RG'"
          if [ -z "$NEW_DIGEST" ]; then echo "No digest to persist; skipping tag update."; exit 0; fi
          TAG_ARGS=("raptor.lastDigest=${NEW_DIGEST}")
          if [ -n "$NEW_SHA" ]; then TAG_ARGS+=("raptor.lastCommit=${NEW_SHA}"); fi
          az resource tag -n "$APP_NAME" -g "$RG" ${SUB:+--subscription "$SUB"} \
            --resource-type "Microsoft.App/containerApps" \
            --is-incremental \
            --tags "${TAG_ARGS[@]}" >/dev/null

